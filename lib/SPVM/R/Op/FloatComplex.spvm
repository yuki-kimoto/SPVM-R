# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Op::FloatComplex extends R::Op {
  
  use R::NDArray::Int;
  use R::NDArray::Long;
  use R::NDArray::Float;
  use R::NDArray::Double;
  use R::NDArray::FloatComplex;
  use R::NDArray::DoubleComplex;
  use R::NDArray::String;
  use R::Op::Int;
  use R::Op::Long;
  use R::Op::Float;
  use R::Op::Double;
  use R::Op::FloatComplex;
  use R::Op::DoubleComplex;
  use R::Op::String;
  use Fn;
  use Complex_2f;
  use Complex_2d;
  use Math;
  
  # Class Methods
  static method new : R::Op::FloatComplex () {
    
    my $self = new R::Op::FloatComplex;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::FloatComplex ($x_data : Complex_2f[], $x_dim : int[] = undef) {
    
    my $x_ndarray = R::NDArray::FloatComplex->new({dim => $x_dim, data => $x_data});
    
    return $x_ndarray;
  }
  
  
  method add : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2f[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->caddf($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sub : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2f[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csubf($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method mul : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2f[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cmulf($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method div : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2f[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cdivf($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method clone : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::FloatComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (float)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (float)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method to_double_complex : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::DoubleComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (double)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (double)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method abs : R::NDArray::Float ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Float->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cabsf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method neg : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cnegf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sin : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csinf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }

  precompile method cos : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccosf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tan : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctanf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sinh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csinhf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method cosh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccoshf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tanh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctanhf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acos : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacosf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asin : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casinf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atan : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catanf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asinh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casinhf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acosh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacoshf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atanh : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catanhf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method exp : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cexpf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method log : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->clogf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sqrt : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csqrtf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method conj : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->conjf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method arg : R::NDArray::Float ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Float->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cargf($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method re : R::NDArray::Float ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Float->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re};
    }
    
    return $ret_ndarray;
  }
  
  precompile method im : R::NDArray::Float ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Float->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method pow : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cpowf($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method eq : R::NDArray::Int ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method ne : R::NDArray::Int ($x_ndarray : R::NDArray::FloatComplex, $y_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Op::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = !($x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im});
    }
    
    return $ret_ndarray;
  }
  
  precompile method sum : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2f;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->caddf($sum, $x_data->[$i]);
    }
    $ret_data->[0] = $sum;
    
    return $ret_ndarray;
  }
  
  precompile method cumsum : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2f;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->caddf($sum, $x_data->[$i]);
      $ret_data->[$i] = $sum;
    }
    
    return $ret_ndarray;
  }
  
  precompile method prod : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complexf(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmulf($prod, $x_data->[$i]);
    }
    $ret_data->[0] = $prod;
    
    return $ret_ndarray;
  }
  
  precompile method cumprod : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::FloatComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complexf(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmulf($prod, $x_data->[$i]);
      $ret_data->[$i] = $prod;
    }
    
    return $ret_ndarray;
  }
  
  method complex : R::NDArray::FloatComplex ($pairs : float[]) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_length = @$pairs;
    
    unless ($pairs_length % 2 == 0) {
      die "The length of the pairs \$pairs must be even number.";
    }
    
    my $length = $pairs_length / 2;
    
    my $ret_ndarray = $self->c(undef, [$length]);
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $pairs_length; $i += 2) {
      $ret_data->[$i]{re} = $pairs->[$i];
      $ret_data->[$i]{im} = $pairs->[$i + 1];
    }
    
    return $ret_ndarray;
  }
  
  method i : R::NDArray::FloatComplex () {
    
    my $i = $self->complex([0f,1f]);
    
    return $i;
  }
  
}
