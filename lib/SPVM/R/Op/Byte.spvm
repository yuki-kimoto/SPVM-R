# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Op::Byte extends R::Op {
  
  use R::NDArray::Byte;
  use ByteList;
  
  # Class Methods
  static method new : R::Op::Byte () {
    
    my $self = new R::Op::Byte;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::Byte ($x_data : byte[], $x_dim : int[] = undef) {
    
    my $x_ndarray = R::NDArray::Byte->new({dim => $x_dim, data => $x_data});
    
    return $x_ndarray;
  }
  
  method rep : R::NDArray::Byte ($x_ndarray : R::NDArray::Byte, $times : int) {
    return (R::NDArray::Byte)$self->SUPER::rep($x_ndarray, $times);
  }
  
  method rep_length : R::NDArray::Byte ($x_ndarray : R::NDArray::Byte, $length : int) {
    return (R::NDArray::Byte)$self->SUPER::rep_length($x_ndarray, $length);
  }
  
  method seq : R::NDArray::Byte ($x : byte, $y : byte, $by : byte = 1) {
    
    my $ret_data_list = ByteList->new;
    my $current = $x;
    while (1) {
      if ($by >= 0) {
        if ($current <= $y) {
          last;
        }
      }
      else {
        if ($current >= $y) {
          last;
        }
      }
      $current += $by;
      $ret_data_list->push($current);
    }
    
    my $ret_data = $ret_data_list->to_array;
    
    my $ret_ndarray = $self->c($ret_data);
    
    return $ret_ndarray;
  }
  
  method seq_length : R::NDArray::Byte ($x : byte, $y : byte, $length : int) {
    
    my $by = (byte)(($y - $x) / $length);
    
    my $ret_ndarray = $self->seq($x, $y, $by);
    
    return $ret_ndarray;
  }
  
}
