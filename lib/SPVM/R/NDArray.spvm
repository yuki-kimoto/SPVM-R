# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::NDArray {
  
  use Hash;
  use IntList;
  use Native::MethodCall;
  
  # Fields
  has data : protected object;
  method data : object () { die "Not implemented."; }
  
  has element_size : ro protected int;
  
  has is_numeric : ro byte;
  
  has type : ro protected string;
  
  has dim : int[];
  
  method dim : int[] () {
    
    my $dim = $self->{dim};
    
    my $dim_clone = copy $dim;
    
    return $dim_clone;
  }
  
  method set_dim : void ($dim : int[]) {
    
    my $nomalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $nomalized_dim;
    
    $self->check;
  }
  
  # Class Mehtods
  static method new : R::NDArray ($options : object[] = undef) {
    
    my $self = new R::NDArray;
    
    $self->init($options);
    
    return $self;
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $element_size = $options_h->get_or_default_int("element_size", -1);
    unless ($element_size > 0) {
      die "element_size option must be greter than 0.";
    }
    $self->{element_size} = $element_size;
    
    my $is_numeric = $options_h->get_or_default_int("is_numeric", 0);
    unless ($is_numeric > 0) {
      die "is_numeric option must be greter than 0.";
    }
    $self->{is_numeric} = (byte)$is_numeric;
    
    my $type = $options_h->get_or_default_string("type", undef);
    unless ($type) {
      die "type option must be defined.";
    }
    unless (length $type) {
      die "The length of \"type\" option must greater than 0.";
    }
    $self->{type} = $type;
    
    my $dim = (int[])$options_h->get_or_default("dim", undef);
    
    my $normalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $normalized_dim;
    
    my $data = $options_h->get_or_default("data", undef);
    
    unless ($data) {
      my $length = $self->length;
      
      $data = $self->create_default_data($length);
    }
    
    $self->{data} = $data;
    
    $self->check;
  }
  
  method length : int () {
    
    my $dim = $self->{dim};
    
    my $length = 1;
    for my $dim_element (@$dim) {
      
      unless ($dim_element > 0) {
        die "[Unexpected Error]The element of dim field must be greater than 0.";
      }
      
      $length *= $dim_element;
    }
    
    return $length;
  }
  
  private method normalize_dim : int[] ($dim : int[]) {
    
    my $normalized_dim_list = IntList->new;
    
    my $normalized_dim = (int[])undef;
    if ($dim) {
      my $dim_length = @$dim;
      my $check_tail_zero = 1;
      for (my $i = $dim_length - 1; $i >= 0; $i--) {
        my $dim_element = $dim->[$i];
        if ($check_tail_zero && $dim_element == 0) {
          next;
        }
        
        if ($dim_element != 0) {
          $check_tail_zero = 0;
        }
        
        unless ($dim_element > 0) {
          die "The element of dim option or \$dim argument except for tail must be greater than 0.";
        }
        
        $normalized_dim_list->unshift($dim_element);
      }
      
      $normalized_dim = $normalized_dim_list->to_array;
    }
    else {
      $normalized_dim = new int[0];
    }
    
    return $normalized_dim;
  }
  
  protected method check : void () { die "Not implemented."; }
  
  protected method create_default_data : object ($length : int) { die "Not implemented."; }
  
  method clone : object () {
    
    my $element_size = $self->{element_size};
    
    my $is_numeric = $self->{is_numeric};
    
    my $length = $self->length;
    
    my $clone_data = $self->create_default_data($length);
    
    my $data = $self->{data};
    
    if ($is_numeric) {
      Fn->memcpy($clone_data, 0, $data, 0, $element_size * $length);
    }
    else {
      for (my $i = 0; $i < $length; $i++) {
        $clone_data->(object[])->[$i] = $data->(object[])->[$i];
      }
    }
    
    my $clone_dim = $self->dim;
    
    my $class_name = type_name $self;
    
    my $clone = Native::MethodCall->call_class_method($class_name, "new", [{data => $clone_data, dim => $clone_dim}]);
    
    return $clone;
  }
  
  method to_string : string () {
    # TODO
  }
  
  method element_to_string : string ($element_ref : object) { die "Not impelmented."; }
  
}

=pod TODO

    SV* pos_to_index(SV* sv_pos, SV* sv_dim) {
      
      SV* sv_index = Rstats::pl_new_avrv();
      Rstats::Integer pos = SvIV(sv_pos);
      Rstats::Integer before_dim_product = 1;
      for (Rstats::Integer i = 0; i < Rstats::pl_av_len(sv_dim); i++) {
        before_dim_product *= SvIV(Rstats::pl_av_fetch(sv_dim, i));
      }
      
      for (Rstats::Integer i = Rstats::pl_av_len(sv_dim) - 1; i >= 0; i--) {
        Rstats::Integer dim_product = 1;
        for (Rstats::Integer k = 0; k < i; k++) {
          dim_product *= SvIV(Rstats::pl_av_fetch(sv_dim, k));
        }
        
        Rstats::Integer reminder = pos % before_dim_product;
        Rstats::Integer quotient = (Rstats::Integer)(reminder / dim_product);
        
        Rstats::pl_av_unshift(sv_index, Rstats::pl_new_sv_iv(quotient + 1));
        before_dim_product = dim_product;
      }
      
      return sv_index;
    }

    SV* index_to_pos(SV* sv_index, SV* sv_dim_values) {
      
      Rstats::Integer pos = 0;
      for (Rstats::Integer i = 0; i < Rstats::pl_av_len(sv_dim_values); i++) {
        if (i > 0) {
          Rstats::Integer tmp = 1;
          for (Rstats::Integer k = 0; k < i; k++) {
            tmp *= SvIV(Rstats::pl_av_fetch(sv_dim_values, k));
          }
          pos += tmp * (SvIV(Rstats::pl_av_fetch(sv_index, i)) - 1);
        }
        else {
          pos += SvIV(Rstats::pl_av_fetch(sv_index, i));
        }
      }
      
      SV* sv_pos = Rstats::pl_new_sv_iv(pos - 1);
      
      return sv_pos;
    }

=cut
