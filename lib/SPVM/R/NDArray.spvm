# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::NDArray {
  
  use Hash;
  use IntList;
  use Native::MethodCall;
  use StringBuffer;
  
  # Fields
  has data : protected object;
  method data : object () { die "Not implemented."; }
  
  has element_size : ro protected int;
  
  has is_numeric : ro byte;
  
  has type : ro protected string;
  
  has dim : int[];
  
  method dim : int[] () {
    
    my $dim = $self->{dim};
    
    my $dim_clone = copy $dim;
    
    return $dim_clone;
  }
  
  method set_dim : void ($dim : int[]) {
    
    my $nomalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $nomalized_dim;
    
    $self->check;
  }
  
  # Class Mehtods
  static method new : R::NDArray ($options : object[] = undef) {
    
    my $self = new R::NDArray;
    
    $self->init($options);
    
    return $self;
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $element_size = $options_h->get_or_default_int("element_size", -1);
    unless ($element_size > 0) {
      die "element_size option must be greter than 0.";
    }
    $self->{element_size} = $element_size;
    
    my $is_numeric = $options_h->get_or_default_int("is_numeric", 0);
    unless ($is_numeric > 0) {
      die "is_numeric option must be greter than 0.";
    }
    $self->{is_numeric} = (byte)$is_numeric;
    
    my $type = $options_h->get_or_default_string("type", undef);
    unless ($type) {
      die "type option must be defined.";
    }
    unless (length $type) {
      die "The length of \"type\" option must greater than 0.";
    }
    $self->{type} = $type;
    
    my $dim = (int[])$options_h->get_or_default("dim", undef);
    
    my $normalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $normalized_dim;
    
    my $data = $options_h->get_or_default("data", undef);
    
    unless ($data) {
      my $length = $self->length;
      
      $data = $self->create_default_data($length);
    }
    
    $self->{data} = $data;
    
    $self->check;
  }
  
  method length : int () {
    
    my $dim = $self->{dim};
    
    my $length = $self->_length($dim);
    
    return $length;
  }
  
  private method _length : int ($dim : int[]) {
    
    my $length = 1;
    for my $dim_element (@$dim) {
      
      unless ($dim_element > 0) {
        die "[Unexpected Error]The element of dim field must be greater than 0.";
      }
      
      $length *= $dim_element;
    }
    
    return $length;
  }
  
  private method normalize_dim : int[] ($dim : int[]) {
    
    my $normalized_dim_list = IntList->new;
    
    my $normalized_dim = (int[])undef;
    if ($dim) {
      my $dim_length = @$dim;
      my $check_tail_zero = 1;
      for (my $i = $dim_length - 1; $i >= 0; $i--) {
        my $dim_element = $dim->[$i];
        if ($check_tail_zero && $dim_element == 0) {
          next;
        }
        
        if ($dim_element != 0) {
          $check_tail_zero = 0;
        }
        
        unless ($dim_element > 0) {
          die "The element of dim option or \$dim argument except for tail must be greater than 0.";
        }
        
        $normalized_dim_list->unshift($dim_element);
      }
      
      $normalized_dim = $normalized_dim_list->to_array;
    }
    else {
      $normalized_dim = new int[0];
    }
    
    return $normalized_dim;
  }
  
  protected method check : void () { die "Not implemented."; }
  
  protected method create_default_data : object ($length : int) { die "Not implemented."; }
  
  method clone : object () {
    
    my $element_size = $self->{element_size};
    
    my $is_numeric = $self->{is_numeric};
    
    my $length = $self->length;
    
    my $clone_data = $self->create_default_data($length);
    
    my $data = $self->{data};
    
    if ($is_numeric) {
      Fn->memcpy($clone_data, 0, $data, 0, $element_size * $length);
    }
    else {
      for (my $i = 0; $i < $length; $i++) {
        $clone_data->(object[])->[$i] = $data->(object[])->[$i];
      }
    }
    
    my $clone_dim = $self->dim;
    
    my $class_name = type_name $self;
    
    my $clone = Native::MethodCall->call_class_method($class_name, "new", [{data => $clone_data, dim => $clone_dim}]);
    
    return $clone;
  }
  
  method element_to_string : string ($data_index : int) { die "Not impelmented."; }
  
  method is_empty : int () {
    
    my $dim = $self->{dim};
    
    my $is_empty = 0;
    if (@$dim == 0) {
      $is_empty = 1;
    }
    
    return $is_empty;
  }
  
  method is_scalar : int () {
    
    my $dim = $self->{dim};
    
    my $is_scalar = 0;
    if ($self->is_vector && $dim->[0] == 1) {
      $is_scalar = 1;
    }
    
    return $is_scalar;
  }
  
  method is_vector : int () {
    
    my $dim = $self->{dim};
    
    my $is_vector = 0;
    if (@$dim == 1) {
      $is_vector = 1;
    }
    
    return $is_vector;
  }
  
  method is_matrix : int () {
    
    my $dim = $self->{dim};
    
    my $is_matrix = 0;
    if (@$dim == 2) {
      $is_matrix = 1;
    }
    
    return $is_matrix;
  }
  
  method is_square_matrix : int () {
    
    my $dim = $self->{dim};
    
    my $is_square_matrix = 0;
    if ($self->is_matrix && $dim->[0] == $dim->[0]) {
      $is_square_matrix = 1;
    }
    
    return $is_square_matrix;
  }
  
  method get : R::NDArray ($vector_indexes : R::NDArray::Int[]) {
    
    my $dim = $self->{dim};
    
    $vector_indexes = $self->normalize_vector_indexes($vector_indexes, $dim);
    
    my $ret_dim = $self->create_ret_dim($vector_indexes);
    
    my $data_indexes = $self->create_data_indexes($vector_indexes, $dim);
    
    my $ret_data = $self->get_data($data_indexes);
    
    my $class_name = type_name $self;
    
    my $ret_ndarray = (R::NDArray)Native::MethodCall->call_class_method($class_name, "new", [{data => $ret_data, dim => $ret_dim}]);
    
    return $ret_ndarray;
  }
  
  method set : R::NDArray ($vector_indexes : R::NDArray::Int[], $ndarray : R::NDArray) {
    
    my $dim = $self->{dim};
    
    $vector_indexes = $self->normalize_vector_indexes($vector_indexes, $dim);
    
    my $ret_dim = $self->create_ret_dim($vector_indexes);
    
    my $data_indexes = $self->create_data_indexes($vector_indexes, $dim);
    
    my $equals_dropped_dim = $self->_equals_dropped_dim($ndarray->dim, $ret_dim);
    
    unless ($equals_dropped_dim) {
      die "The dim field of \$ndarray must be compatible with dim created by \$vector_indexes.";
    }
    
    my $ret_data = $self->set_data($data_indexes, $ndarray->data);
    
    my $class_name = type_name $self;
    
    my $ret_ndarray = (R::NDArray)Native::MethodCall->call_class_method($class_name, "new", [{data => $ret_data, dim => $ret_dim}]);
    
    return $ret_ndarray;
  }
  
  protected method get_data : object ($data_indexes : int[]) { die "Not implemented."; }
  
  protected method set_data : object ($data_indexes : int[], $data : object) { die "Not implemented."; }
  
  private method normalize_vector_indexes : R::NDArray::Int[] ($vector_indexes : R::NDArray::Int[], $dim : int[]) {
    
    unless ($vector_indexes) {
      die "The indexes for n-dimension array \$vector_indexes must be defined.";
    }
    
    my $vector_indexes_length = @$vector_indexes;
    
    my $dim_length = @$dim;
    
    unless ($vector_indexes_length <= $dim_length) {
      die "The length of indexes for n-dimension array \$vector_indexes must be less than or equal to the length of dim field.";
    }
    
    my $normalized_vector_indexes = new R::NDArray::Int[$vector_indexes_length];
    
    for (my $vector_indexes_index = 0; $vector_indexes_index < $dim_length; $vector_indexes_index++) {
      my $vector_index = $vector_indexes->[$vector_indexes_index];
      
      unless (!$vector_index || $vector_index->is_vector) {
        die "The element of indexes for n-dimension array \$vector_indexes must be undef or vector.";
      }
      
      unless ($vector_index) {
        $vector_index = R::NDArray::Int->new({dim => [$dim->[$vector_indexes_index]]});
      }
      
      $normalized_vector_indexes->[$vector_indexes_index] = $vector_index;
    }
    
    return $normalized_vector_indexes;
  }
  
  private method create_ret_dim : int[] ($vector_indexes : R::NDArray::Int[]) {
    
    my $vector_indexes_length = @$vector_indexes;
    
    my $ret_dim = new int[$vector_indexes_length];
    
    for (my $i = 0; $i < $vector_indexes_length; $i++) {
      my $vector_index = $vector_indexes->[$i];
      
      if ($vector_index) {
        $ret_dim->[$i] = $vector_index->length;
      }
      else {
        die "[Unexpected]\$vector_index must be defined.";
      }
    }
    
    return $ret_dim;
  }
  
  private method create_data_indexes : int[] ($vector_indexes : R::NDArray::Int[], $dim : int[]) {
    
    my $ret_dim = $self->create_ret_dim($vector_indexes);
    
    my $ret_dim_length = @$ret_dim;
    
    my $ret_length = $self->_length($ret_dim);
    
    my $ret_data = $self->create_default_data($ret_length);
    
    my $data_indexes = new int[$ret_length];
    
    for (my $ret_data_index = 0; $ret_data_index < $ret_length; $ret_data_index++) {
      my $ret_cordinate = $self->convert_data_index_to_coordinate($ret_data_index, $ret_dim);
      
      my $cordinate = new int[$ret_dim_length];
      
      for (my $cordinate_index = 0; $cordinate_index < @$cordinate; $cordinate_index++) {
        my $ret_cordinate_x = $ret_cordinate->[$cordinate_index];
        $cordinate->[$cordinate_index] = $vector_indexes->[$cordinate_index]->data->[$ret_cordinate_x];
      }
      
      my $data_index = $self->convert_coordinate_to_data_index($cordinate, $dim);
      
      $data_indexes->[$ret_data_index] = $data_index;
    }
    
    return $data_indexes;
  }
  
  precompile private method convert_coordinate_to_data_index : int ($coordinate : int[], $dim : int[]) {
    
    my $data_index = 0;
    my $dim_length = @$dim;
    for (my $i = 0; $i < $dim_length; $i++) {
      if ($i > 0) {
        my $tmp = 1;
        for (my $k = 0; $k < $i; $k++) {
          $tmp *= $dim->[$k];
        }
        $data_index += $tmp * $coordinate->[$i] - 1;
      }
      else {
        $data_index += $coordinate->[$i];
      }
    }
    
    $data_index -= 1;
    
    return $data_index;
  }
  
  precompile private method convert_data_index_to_coordinate : int[] ($data_index : int, $dim : int[]) {
    
    my $dim_length = @$dim;
    
    my $coordinate = new int[$dim_length];
    
    my $before_dim_product = 1;
    for (my $i = 0; $i < $dim_length; $i++) {
      $before_dim_product *= $dim->[$i];
    }
    
    for (my $i = $dim_length - 1; $i >= 0; $i--) {
      my $dim_product = 1;
      for (my $k = 0; $k < $i; $k++) {
        $dim_product *= $dim->[$k];
      }
      
      my $reminder = $data_index % $before_dim_product;
      my $quotient = $reminder / $dim_product;
      
      $coordinate->[$i] = $quotient + 1;
      $before_dim_product = $dim_product;
    }
    
    return $coordinate;
  }
  
  method equals_dim : int ($y_ndarray : R::NDArray) {
    
    my $x_ndarray = $self;
    
    unless ($x_ndarray) {
      die "The n-dimention array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimention array \$y_ndarray must be defined.";
    }
    
    my $x_dim = $x_ndarray->dim;
    
    my $y_dim = $y_ndarray->dim;
    
    my $equals_dim = $self->_equals_dim($x_dim, $y_dim);
    
    return $equals_dim;
  }
  
  method _equals_dim : int ($x_dim : int[], $y_dim : int[]) {
    
    my $equals_dim = 0;
    if ($x_dim && $y_dim) {
      my $x_dim_length = @$x_dim;
      
      my $y_dim_length = @$y_dim;
      
      if ($x_dim_length == $y_dim_length) {
        my $equals_dim_elements = 1;
        for (my $i = 0; $i < $x_dim_length; $i++) {
          my $x_dim_element = $x_dim->[$i];
          my $y_dim_element = $y_dim->[$i];
          
          unless ($x_dim_element == $y_dim_element) {
            $equals_dim_elements = 0;
            last;
          }
        }
        $equals_dim = $equals_dim_elements;
      }
    }
    elsif (!$x_dim && !$y_dim) {
      $equals_dim = 1;
    }
    
    return $equals_dim;
  }
  
  private method _drop_dim : int[] ($dim : int[]) {
    
    unless ($dim) {
      die "[Unexpected Error]\$dim must be defined.";
    }
    
    unless (@$dim > 0) {
      die "[Unexpected Error]The length of \$dim must be greater than 0.";
    }
    
    my $dropped_dim_list = IntList->new;
    
    for (my $i = 0; $i < @$dim; $i++) {
      my $dim_element = $dim->[$i];
      unless ($dim_element == 1) {
        $dropped_dim_list->push($dim_element);
      }
    }
    
    if ($dropped_dim_list->length == 0) {
      $dropped_dim_list->push(1);
    }
    
    my $dropped_dim = $dropped_dim_list->to_array;
    
    return $dropped_dim;
  }
  
  method drop_dim : void () {
    
    my $dim = $self->{dim};
    
    my $dropped_dim = $self->_drop_dim($dim);
    
    $self->set_dim($dropped_dim);
  }
  
  method equals_dropped_dim : int ($y_ndarray : R::NDArray) {
    
    my $x_ndarray = $self;
    
    unless ($x_ndarray) {
      die "The n-dimention array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimention array \$y_ndarray must be defined.";
    }
    
    my $x_dim = $x_ndarray->dim;
    
    my $y_dim = $y_ndarray->dim;
    
    my $equals_dropped_dim = $self->_equals_dropped_dim($x_dim, $y_dim);
    
    return $equals_dropped_dim;
  }
  
  private method _equals_dropped_dim : int ($x_dim : int[], $y_dim : int[]) {
    
    my $x_dropped_dim = $self->_drop_dim($x_dim);
    
    my $y_dropped_dim = $self->_drop_dim($y_dim);
    
    my $equals_dropped_dim = $self->_equals_dim($x_dropped_dim, $y_dropped_dim);
    
    return $equals_dropped_dim;
  }
  
  method to_string : string () {
    
    my $dim = $self->{dim};
    
    my $dim_length = @$dim;
    my $dim_num = $dim_length - 1;
    my $poss = [];
    
    my $data = $self->{data};
    
    my $string = (string)undef;
    if ($self->is_empty) {
      $string = "Empty";
    }
    elsif ($self->is_vector) {
      my $data_length = $self->length;
      my $string_buffer = StringBuffer->new;
      $string_buffer->push("[0] ");
      for (my $i = 0; $i < $data_length; $i++) {
        my $element_string = $self->element_to_string($i);
        $string_buffer->push($element_string);
      }
      $string_buffer->push("\n  ");
      
      $string = $string_buffer->to_string;
    }
    elsif ($self->is_matrix) {
      my $string_buffer = StringBuffer->new;
      
      $string_buffer->push("     ");
      
      for (my $d2 = 0; $d2 < $dim->[0]; $d2++) {
        $string_buffer->push(",$d2]");
        if ($d2 == $dim->[0]) {
          $string_buffer->push("\n");
        }
        else {
          $string_buffer->push(" ");
        }
      }
      
      for (my $d1 = 0; $d1 < $dim->[0]; $d1++) {
        $string_buffer->push("[$d1,] ");
        
        for (my $d2 = 0; $d2 < $dim->[0]; $d2++) {
          
          my $cordinate = [$d1, $d2];
          
          my $data_index = $self->convert_coordinate_to_data_index($cordinate, $dim);
          
          my $element_string = $self->element_to_string($data_index);
          
          $string_buffer->push($element_string);
        }
        
        $string_buffer->push("\n");
      }
    }
    else {
    }
    
    return $string;
  }
  
  method nrow : int () {
    
    unless ($self->is_matrix) {
      die "The invocant must be a matrix.";
    }
    
    my $dim = $self->{dim};
    
    my $nrow = $dim->[0];
    
    return $nrow;
  }
  
  method ncol : int () {
    
    unless ($self->is_matrix) {
      die "The invocant must be a matrix.";
    }
    
    my $dim = $self->{dim};
    
    my $ncol = $dim->[1];
    
    return $ncol;
  }
  
}

=pod TODO

sub to_string_array {
  my $r = shift;
  
  my $x1 = shift;
  
  my $is_factor = Rstats::Func::is_factor($r, $x1);
  my $is_ordered = Rstats::Func::is_ordered($r, $x1);
  my $levels;
  if ($is_factor) {
    $levels = Rstats::Func::levels($r, $x1)->values;
  }
  
  $x1 = Rstats::Func::as_character($r, $x1) if Rstats::Func::is_factor($r, $x1);
  
  my $is_character = Rstats::Func::is_character($r, $x1);

  my $values = $x1->values;
  my $type = $x1->get_type;
  
  my $dim_values = $x1->dim_as_array->values;
  
  my $dim_length = @$dim_values;
  my $dim_num = $dim_length - 1;
  my $poss = [];
  
  my $string;
  if (@$values) {
    if ($dim_length == 1) {
      my $names = Rstats::Func::names($r, $x1)->values;
      if (@$names) {
        $string .= join(' ', @$names) . "\n";
      }
      my @parts = map { Rstats::Func::_value_to_string($r, $x1, $_, $type, $is_factor) } @$values;
      $string .= '[1] ' . join(' ', @parts) . "\n";
    }
    elsif ($dim_length == 2) {
      $string .= '     ';
      
      my $colnames = Rstats::Func::colnames($r, $x1)->values;
      if (@$colnames) {
        $string .= join(' ', @$colnames) . "\n";
      }
      else {
        for my $d2 (1 .. $dim_values->[1]) {
          $string .= $d2 == $dim_values->[1] ? "[,$d2]\n" : "[,$d2] ";
        }
      }
      
      my $rownames = Rstats::Func::rownames($r, $x1)->values;
      my $use_rownames = @$rownames ? 1 : 0;
      for my $d1 (1 .. $dim_values->[0]) {
        if ($use_rownames) {
          my $rowname = $rownames->[$d1 - 1];
          $string .= "$rowname ";
        }
        else {
          $string .= "[$d1,] ";
        }
        
        my @parts;
        for my $d2 (1 .. $dim_values->[1]) {
          my $part = $x1->value($d1, $d2);
          push @parts, Rstats::Func::_value_to_string($r, $x1, $part, $type, $is_factor);
        }
        
        $string .= join(' ', @parts) . "\n";
      }
    }
    else {
      my $code;
      $code = sub {
        my (@dim_values) = @_;
        my $dim_value = pop @dim_values;
        
        for (my $i = 1; $i <= $dim_value; $i++) {
          $string .= (',' x $dim_num) . "$i" . "\n";
          unshift @$poss, $i;
          if (@dim_values > 2) {
            $dim_num--;
            $code->(@dim_values);
            $dim_num++;
          }
          else {
            $string .= '     ';
            
            my $l_dimnames = Rstats::Func::dimnames($r, $x1);
            my $dimnames;
            if (Rstats::Func::is_null($r, $l_dimnames)) {
              $dimnames = [];
            }
            else {
              my $x_dimnames = $l_dimnames->getin($i);
              $dimnames = defined $l_dimnames ? $l_dimnames->values : [];
            }
            
            if (@$dimnames) {
              $string .= join(' ', @$dimnames) . "\n";
            }
            else {
              for my $d2 (1 .. $dim_values[1]) {
                $string .= $d2 == $dim_values[1] ? "[,$d2]\n" : "[,$d2] ";
              }
            }

            for my $d1 (1 .. $dim_values[0]) {
              $string .= "[$d1,] ";
              
              my @parts;
              for my $d2 (1 .. $dim_values[1]) {
                my $part = $x1->value($d1, $d2, @$poss);
                push @parts, Rstats::Func::_value_to_string($r, $x1, $part, $type, $is_factor);
              }
              
              $string .= join(' ', @parts) . "\n";
            }
          }
          shift @$poss;
        }
      };
      $code->(@$dim_values);
    }

    if ($is_factor) {
      if ($is_ordered) {
        $string .= 'Levels: ' . join(' < ', @$levels) . "\n";
      }
      else {
        $string .= 'Levels: ' . join(' ', , @$levels) . "\n";
      }
    }
  }
  else {
    $string = 'NULL';
  }
  
  return $string;
}

sub order {
  my $r = shift;
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my @xs = map { to_object($r, $_) } @_;
  
  my @xs_values;
  for my $x (@xs) {
    push @xs_values, $x->values;
  }

  my $decreasing = $opt->{decreasing} || Rstats::Func::FALSE($r);
  
  my @pos_vals;
  for my $i (0 .. @{$xs_values[0]} - 1) {
    my $pos_val = {pos => $i + 1};
    $pos_val->{val} = [];
    push @{$pos_val->{val}}, $xs_values[$_][$i] for (0 .. @xs_values);
    push @pos_vals, $pos_val;
  }
  
  my @sorted_pos_values = !$decreasing
    ? sort {
        my $comp;
        for (my $i = 0; $i < @xs_values; $i++) {
          $comp = $a->{val}[$i] <=> $b->{val}[$i];
          last if $comp != 0;
        }
        $comp;
      } @pos_vals
    : sort {
        my $comp;
        for (my $i = 0; $i < @xs_values; $i++) {
          $comp = $b->{val}[$i] <=> $a->{val}[$i];
          last if $comp != 0;
        }
        $comp;
      } @pos_vals;
  my @orders = map { $_->{pos} } @sorted_pos_values;
  
  return Rstats::Func::c_($r, @orders);
}

=cut
