# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::NDArray {
  
  use Hash;
  use IntList;
  use Native::MethodCall;
  
  # Fields
  has data : protected object;
  method data : object () { die "Not implemented."; }
  
  has element_size : ro protected int;
  
  has is_numeric : ro byte;
  
  has type : ro protected string;
  
  has dim : int[];
  
  method dim : int[] () {
    
    my $dim = $self->{dim};
    
    my $dim_clone = copy $dim;
    
    return $dim_clone;
  }
  
  method set_dim : void ($dim : int[]) {
    
    my $nomalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $nomalized_dim;
    
    $self->check;
  }
  
  # Class Mehtods
  static method new : R::NDArray ($options : object[] = undef) {
    
    my $self = new R::NDArray;
    
    $self->init($options);
    
    return $self;
  }
  
  # Instance Methods
  protected method init : void ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    my $element_size = $options_h->get_or_default_int("element_size", -1);
    unless ($element_size > 0) {
      die "element_size option must be greter than 0.";
    }
    $self->{element_size} = $element_size;
    
    my $is_numeric = $options_h->get_or_default_int("is_numeric", 0);
    unless ($is_numeric > 0) {
      die "is_numeric option must be greter than 0.";
    }
    $self->{is_numeric} = (byte)$is_numeric;
    
    my $type = $options_h->get_or_default_string("type", undef);
    unless ($type) {
      die "type option must be defined.";
    }
    unless (length $type) {
      die "The length of \"type\" option must greater than 0.";
    }
    $self->{type} = $type;
    
    my $dim = (int[])$options_h->get_or_default("dim", undef);
    
    my $normalized_dim = $self->normalize_dim($dim);
    
    $self->{dim} = $normalized_dim;
    
    my $data = $options_h->get_or_default("data", undef);
    
    unless ($data) {
      my $length = $self->length;
      
      $data = $self->create_default_data($length);
    }
    
    $self->{data} = $data;
    
    $self->check;
  }
  
  method length : int () {
    
    my $dim = $self->{dim};
    
    my $length = 1;
    for my $dim_element (@$dim) {
      
      unless ($dim_element > 0) {
        die "[Unexpected Error]The element of dim field must be greater than 0.";
      }
      
      $length *= $dim_element;
    }
    
    return $length;
  }
  
  private method normalize_dim : int[] ($dim : int[]) {
    
    my $normalized_dim_list = IntList->new;
    
    my $normalized_dim = (int[])undef;
    if ($dim) {
      my $dim_length = @$dim;
      my $check_tail_zero = 1;
      for (my $i = $dim_length - 1; $i >= 0; $i--) {
        my $dim_element = $dim->[$i];
        if ($check_tail_zero && $dim_element == 0) {
          next;
        }
        
        if ($dim_element != 0) {
          $check_tail_zero = 0;
        }
        
        unless ($dim_element > 0) {
          die "The element of dim option or \$dim argument except for tail must be greater than 0.";
        }
        
        $normalized_dim_list->unshift($dim_element);
      }
      
      $normalized_dim = $normalized_dim_list->to_array;
    }
    else {
      $normalized_dim = new int[0];
    }
    
    return $normalized_dim;
  }
  
  protected method check : void () { die "Not implemented."; }
  
  protected method create_default_data : object ($length : int) { die "Not implemented."; }
  
  method clone : object () {
    
    my $element_size = $self->{element_size};
    
    my $is_numeric = $self->{is_numeric};
    
    my $length = $self->length;
    
    my $clone_data = $self->create_default_data($length);
    
    my $data = $self->{data};
    
    if ($is_numeric) {
      Fn->memcpy($clone_data, 0, $data, 0, $element_size * $length);
    }
    else {
      for (my $i = 0; $i < $length; $i++) {
        $clone_data->(object[])->[$i] = $data->(object[])->[$i];
      }
    }
    
    my $clone_dim = $self->dim;
    
    my $class_name = type_name $self;
    
    my $clone = Native::MethodCall->call_class_method($class_name, "new", [{data => $clone_data, dim => $clone_dim}]);
    
    return $clone;
  }
  
  method to_string : string () {
    # TODO
  }
  
  method element_to_string : string ($element_ref : object) { die "Not impelmented."; }
  
  method is_empty : int () {
    
    my $dim = $self->{dim};
    
    my $is_empty = 0;
    if (@$dim == 0) {
      $is_empty = 1;
    }
    
    return $is_empty;
  }
  
  method is_scalar : int () {
    
    my $dim = $self->{dim};
    
    my $is_scalar = 0;
    if ($self->is_vector && $dim->[0] == 1) {
      $is_scalar = 1;
    }
    
    return $is_scalar;
  }
  
  method is_vector : int () {
    
    my $dim = $self->{dim};
    
    my $is_vector = 0;
    if (@$dim == 1) {
      $is_vector = 1;
    }
    
    return $is_vector;
  }
  
  method is_matrix : int () {
    
    my $dim = $self->{dim};
    
    my $is_matrix = 0;
    if (@$dim == 2) {
      $is_matrix = 1;
    }
    
    return $is_matrix;
  }
  
  method is_square_matrix : int () {
    
    my $dim = $self->{dim};
    
    my $is_square_matrix = 0;
    if ($self->is_matrix && $dim->[0] == $dim->[1]) {
      $is_square_matrix = 1;
    }
    
    return $is_square_matrix;
  }
  
  method get : R::NDArray ($vector_indexes : R::NDArray::Int[]) {
    
    my $dim = $self->{dim};
    
    $vector_indexes = $self->normalize_vector_indexes($vector_indexes, $dim);
    
    
  }
  
  private method normalize_vector_indexes : R::NDArray::Int[] ($vector_indexes : R::NDArray::Int[], $dim : int[]) {
    
    unless ($vector_indexes) {
      die "The indexes for n-dimension array \$vector_indexes must be defined.";
    }
    
    my $vector_indexes_length = @$vector_indexes;
    
    unless ($vector_indexes_length <= @$dim) {
      die "The length of indexes for n-dimension array \$vector_indexes must be less than or equal to the length of dim field.";
    }
    
    my $normalized_vector_indexes = new R::NDArray::Int[$vector_indexes_length];
    
    for (my $vector_indexes_index = 0; $vector_indexes_index < $vector_indexes_length; $vector_indexes_index++) {
      my $vector_index = $vector_indexes->[$vector_indexes_index];
      
      unless (!$vector_index || $vector_index->is_vector) {
        die "The element of indexes for n-dimension array \$vector_indexes must be undef or vector.";
      }
      
      unless ($vector_index) {
        $vector_index = R::NDArray::Int->new({dim => [$dim->[$vector_indexes_index]]});
      }
      
      $normalized_vector_indexes->[$vector_indexes_index] = $vector_index;
    }
    
    return $normalized_vector_indexes;
  }
  
  private method create_get_ret_dim : int[] ($vector_indexes : R::NDArray::Int[]) {
    
    my $vector_indexes_length = @$vector_indexes;
    
    my $ret_dim = new int[$vector_indexes_length];
    
    for (my $i = 0; $i < $vector_indexes_length; $i++) {
      my $vector_index = $vector_indexes->[$i];
      
      if ($vector_index) {
        $ret_dim->[$i] = $vector_index->length;
      }
      else {
        die "[Unexpected]\$vector_index must be defined.";
      }
    }
    
    return $ret_dim;
  }

=pod

  private method parse_vector_index : void ($vector_indexes : R::NDArray::Int[], $dim : int[]) {
    
    my $dim_length = @$dim;
    
    my $ret_dim = new int[$dim_length];
    
    for (my $i = 0; $i < $dim_length; $i++) {
      my $vector_index = $vector_indexes->[$i];
      
      if ($vector_index) {
        $ret_dim->[$i] = $dim->[$i];
      }
      else {
        $ret_dim->[$i] = $vector_index->length;
      }
    }
    
    my $vector_index_values = [map { $_->values } $vector_indexes];
    my $ords = cross_product($vector_index_values);
    my $poss = map { $self->convert_ndarray_vector_index_to_data_vector_index($_, $dim) } @$ords;
    
    return [\$poss, \$ret_dim, \$vector_indexes];
  }

=cut

  precompile private method convert_ndarray_index_to_data_index : int ($ndarray_indexes : int[], $dim : int[]) {
    
    my $data_index = 0;
    my $dim_length = @$dim;
    for (my $i = 0; $i < $dim_length; $i++) {
      if ($i > 0) {
        my $tmp = 1;
        for (my $k = 0; $k < $i; $k++) {
          $tmp *= $dim->[$k];
        }
        $data_index += $tmp * $ndarray_indexes->[$i] - 1;
      }
      else {
        $data_index += $ndarray_indexes->[$i];
      }
    }
    
    $data_index -= 1;
    
    return $data_index;
  }
}

=pod
    unless ($vector_indexes) {
      die "The indexes for n-dimension array \$vector_indexes must be defined.";
    }
    
    my $vector_indexes_length = @$vector_indexes;
    
    my $self_dim = $self->{dim};
    
    unless ($vector_indexes_length <= @$self_dim) {
      die "The length of indexes for n-dimension array \$vector_indexes must be less than or equal to the length of dim field.";
    }
    
    for (my $i = 0; $i < $vector_indexes_length; $i++) {
      my $vector_index = $vector_indexes->[$i];
      
      my $indexes = $vector_index->data;
      
      unless (!$vector_index || $vector_index->is_vector) {
        die "The element of indexes for n-dimension array \$vector_indexes must be undef or vector.".
      }
      
      unless ($vector_index) {
        my $dim_max = $self->
      }
      
      my $each_indexes = $vector_index->data;
      
=cut

    
=pod

    my ($ret_data_indexes, $ret_dim, $new_indexes) = @{Rstats::Util::parse_index($self, $indexes_ndarray)};
    
    my $x1_values = $x1->values;
    my @x2_values = map { $x1_values->[$_] } @$poss;
    
    my $ret_ndarray = Native::MethodCall->call_class_method($class_name, "new", [{data => $ret_data}]);
    my $ret_ndarray->set_dim($ret_dim);
    
    return $ret_ndarray;

=cut

=pod

  private method parse_index : void () {
    my $r = shift;
    
    my ($x1, $drop, $_indexs) = @_;
    my @_indexs = @$_indexs;
    
    my $x1_dim = $x1->dim_as_array->values;
    my @indexs;
    my @x2_dim;
    
    for (my $i = 0; $i < @$x1_dim; $i++) {
      my $_index = $_indexs[$i];

      my $index = defined $_index ? Rstats::Func::to_object($r, $_index) : Rstats::Func::NULL($r);
      my $index_values = $index->values;
      if (@$index_values && !Rstats::Func::is_character($r, $index) && !Rstats::Func::is_logical($r, $index)) {
        my $minus_count = 0;
        for my $index_value (@$index_values) {
          if ($index_value == 0) {
            croak "0 is invalid index";
          }
          else {
            $minus_count++ if $index_value < 0;
          }
        }
        croak "Can't min minus sign and plus sign"
          if $minus_count > 0 && $minus_count != @$index_values;
        $index->{_minus} = 1 if $minus_count > 0;
      }
      
      if (!@{$index->values}) {
        my $index_values_new = [1 .. $x1_dim->[$i]];
        $index = Rstats::Func::c_integer($r, @$index_values_new);
      }
      elsif ($index->{_minus}) {
        my $index_value_new = [];
        
        for my $k (1 .. $x1_dim->[$i]) {
          push @$index_value_new, $k unless grep { $_ == -$k } @{$index->values};
        }
        $index = Rstats::Func::c_integer($r, @$index_value_new);
      }

      push @indexs, $index;

      my $count = Rstats::Func::get_length($r, $index);
      push @x2_dim, $count unless $count == 1 && $drop;
    }
    @x2_dim = (1) unless @x2_dim;
    
    my $index_values = [map { $_->values } @indexs];
    my $ords = cross_product($index_values);
    my @poss = map { Rstats::Util::index_to_pos($_, $x1_dim) } @$ords;
    
    return [\@poss, \@x2_dim, \@indexs];
  }
  
=cut

=pod TODO

    SV* cross_product(SV* sv_values) {
      
      Rstats::Integer values_length = Rstats::pl_av_len(sv_values);
      SV* sv_idxs = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        Rstats::pl_av_push(sv_idxs, Rstats::pl_new_sv_iv(0)); 
      }
      
      SV* sv_idx_idx = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        Rstats::pl_av_push(sv_idx_idx, Rstats::pl_new_sv_iv(i));
      }
      
      SV* sv_x1 = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        SV* sv_value = Rstats::pl_av_fetch(sv_values, i);
        Rstats::pl_av_push(sv_x1, Rstats::pl_av_fetch(sv_value, 0));
      }

      SV* sv_result = Rstats::pl_new_avrv();
      Rstats::pl_av_push(sv_result, Rstats::pl_av_copy(sv_x1));
      Rstats::Logical end_loop = 0;
      while (1) {
        for (Rstats::Integer i = 0; i < values_length; i++) {
          
          if (SvIV(Rstats::pl_av_fetch(sv_idxs, i)) < Rstats::pl_av_len(Rstats::pl_av_fetch(sv_values, i)) - 1) {
            
            SV* sv_idxs_tmp = Rstats::pl_av_fetch(sv_idxs, i);
            sv_inc(sv_idxs_tmp);
            Rstats::pl_av_store(sv_x1, i, Rstats::pl_av_fetch(Rstats::pl_av_fetch(sv_values, i), SvIV(sv_idxs_tmp)));
            
            Rstats::pl_av_push(sv_result, Rstats::pl_av_copy(sv_x1));
            
            break;
          }
          
          if (i == SvIV(Rstats::pl_av_fetch(sv_idx_idx, values_length - 1))) {
            end_loop = 1;
            break;
          }
          
          Rstats::pl_av_store(sv_idxs, i, Rstats::pl_new_sv_iv(0));
          Rstats::pl_av_store(sv_x1, i, Rstats::pl_av_fetch(Rstats::pl_av_fetch(sv_values, i), 0));
        }
        if (end_loop) {
          break;
        }
      }

      return sv_result;
    }
    
  sub parse_index {
    my $r = shift;
    
    my ($x1, $drop, $_indexs) = @_;
    my @_indexs = @$_indexs;
    
    my $x1_dim = $x1->dim_as_array->values;
    my @indexs;
    my @x2_dim;
    
    if (ref $_indexs[0] && Rstats::Func::is_array($r, $_indexs[0])
      && Rstats::Func::is_logical($r, $_indexs[0]) && Rstats::Func::dim($r, $_indexs[0])->get_length > 1) {
      my $x2 = $_indexs[0];
      my $x2_dim_values = Rstats::Func::dim($r, $x2)->values;
      my $x2_values = $x2->values;
      my $poss = [];
      for (my $i = 0; $i < @$x2_values; $i++) {
        next unless $x2_values->[$i];
        push @$poss, $i;
      }
      
      return [$poss, []];
    }
    else {
      for (my $i = 0; $i < @$x1_dim; $i++) {
        my $_index = $_indexs[$i];

        my $index = defined $_index ? Rstats::Func::to_object($r, $_index) : Rstats::Func::NULL($r);
        my $index_values = $index->values;
        if (@$index_values && !Rstats::Func::is_character($r, $index) && !Rstats::Func::is_logical($r, $index)) {
          my $minus_count = 0;
          for my $index_value (@$index_values) {
            if ($index_value == 0) {
              croak "0 is invalid index";
            }
            else {
              $minus_count++ if $index_value < 0;
            }
          }
          croak "Can't min minus sign and plus sign"
            if $minus_count > 0 && $minus_count != @$index_values;
          $index->{_minus} = 1 if $minus_count > 0;
        }
        
        if (!@{$index->values}) {
          my $index_values_new = [1 .. $x1_dim->[$i]];
          $index = Rstats::Func::c_integer($r, @$index_values_new);
        }
        elsif (Rstats::Func::is_character($r, $index)) {
          if (Rstats::Func::is_vector($r, $x1)) {
            my $index_new_values = [];
            for my $name (@{$index->values}) {
              my $i = 0;
              my $value;
              for my $x1_name (@{Rstats::Func::names($r, $x1)->values}) {
                if ($name eq $x1_name) {
                  $value = $x1->values->[$i];
                  last;
                }
                $i++;
              }
              croak "Can't find name" unless defined $value;
              push @$index_new_values, $value;
            }
            $indexs[$i] = Rstats::Func::c_integer($r, @$index_new_values);
          }
          elsif (Rstats::Func::is_matrix($r, $x1)) {
            
          }
          else {
            croak "Can't support name except vector and matrix";
          }
        }
        elsif (Rstats::Func::is_logical($r, $index)) {
          my $index_values_new = [];
          for (my $i = 0; $i < @{$index->values}; $i++) {
            push @$index_values_new, $i + 1 if $index_values->[$i];
          }
          $index = Rstats::Func::c_integer($r, @$index_values_new);
        }
        elsif ($index->{_minus}) {
          my $index_value_new = [];
          
          for my $k (1 .. $x1_dim->[$i]) {
            push @$index_value_new, $k unless grep { $_ == -$k } @{$index->values};
          }
          $index = Rstats::Func::c_integer($r, @$index_value_new);
        }

        push @indexs, $index;

        my $count = Rstats::Func::get_length($r, $index);
        push @x2_dim, $count unless $count == 1 && $drop;
      }
      @x2_dim = (1) unless @x2_dim;
      
      my $index_values = [map { $_->values } @indexs];
      my $ords = cross_product($index_values);
      my @poss = map { Rstats::Util::index_to_pos($_, $x1_dim) } @$ords;
    
      return [\@poss, \@x2_dim, \@indexs];
    }
  }
    SV* pos_to_index(SV* sv_pos, SV* sv_dim) {
      
      SV* sv_index = Rstats::pl_new_avrv();
      Rstats::Integer pos = SvIV(sv_pos);
      Rstats::Integer before_dim_product = 1;
      for (Rstats::Integer i = 0; i < Rstats::pl_av_len(sv_dim); i++) {
        before_dim_product *= SvIV(Rstats::pl_av_fetch(sv_dim, i));
      }
      
      for (Rstats::Integer i = Rstats::pl_av_len(sv_dim) - 1; i >= 0; i--) {
        Rstats::Integer dim_product = 1;
        for (Rstats::Integer k = 0; k < i; k++) {
          dim_product *= SvIV(Rstats::pl_av_fetch(sv_dim, k));
        }
        
        Rstats::Integer reminder = pos % before_dim_product;
        Rstats::Integer quotient = (Rstats::Integer)(reminder / dim_product);
        
        Rstats::pl_av_unshift(sv_index, Rstats::pl_new_sv_iv(quotient + 1));
        before_dim_product = dim_product;
      }
      
      return sv_index;
    }

    SV* index_to_pos(SV* sv_index, SV* sv_dim_values) {
      
      Rstats::Integer pos = 0;
      for (Rstats::Integer i = 0; i < Rstats::pl_av_len(sv_dim_values); i++) {
        if (i > 0) {
          Rstats::Integer tmp = 1;
          for (Rstats::Integer k = 0; k < i; k++) {
            tmp *= SvIV(Rstats::pl_av_fetch(sv_dim_values, k));
          }
          pos += tmp * (SvIV(Rstats::pl_av_fetch(sv_index, i)) - 1);
        }
        else {
          pos += SvIV(Rstats::pl_av_fetch(sv_index, i));
        }
      }
      
      SV* sv_pos = Rstats::pl_new_sv_iv(pos - 1);
      
      return sv_pos;
    }

sub get_array {
  my $r = shift;
  
  my $x1 = shift;
  
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my $dim_drop;
  my $level_drop;
  if (Rstats::Func::is_factor($r, $x1)) {
    $level_drop = $opt->{drop};
  }
  else {
    $dim_drop = $opt->{drop};
  }
  
  $dim_drop = 1 unless defined $dim_drop;
  $level_drop = 0 unless defined $level_drop;
  
  my @_indexs = @_;

  my $_indexs;
  if (@_indexs) {
    $_indexs = \@_indexs;
  }
  else {
    my $at = $x1->at;
    $_indexs = ref $at eq 'ARRAY' ? $at : [$at];
  }
  $x1->at($_indexs);
  
  my ($poss, $x2_dim, $new_indexes) = @{Rstats::Util::parse_index($r, $x1, $dim_drop, $_indexs)};
  
  my $x1_values = $x1->values;
  my @x2_values = map { $x1_values->[$_] } @$poss;
  
  # array
  my $x_matrix;
  if ($x1->get_type eq "character") {
    $x_matrix = c_character($r, \@x2_values);
  }
  elsif ($x1->get_type eq "complex") {
    $x_matrix = c_complex($r, \@x2_values);
  }
  elsif ($x1->get_type eq "double") {
    $x_matrix = c_double($r, \@x2_values);
  }
  elsif ($x1->get_type eq "integer") {
    $x_matrix = c_integer($r, \@x2_values);
  }
  elsif ($x1->get_type eq "logical") {
    $x_matrix = c_logical($r, \@x2_values);
  }
  else {
    croak("Invalid type " . $x1->get_type . " is passed");
  }
  
  my $x2 = Rstats::Func::array(
    $r,
    $x_matrix,
    Rstats::Func::c_($r, @$x2_dim)
  );
  
  # Copy attributes
  Rstats::Func::copy_attrs_to($r, $x1, $x2, {new_indexes => $new_indexes, exclude => ['dim']});

  # level drop
  if ($level_drop) {
    my $p = Rstats::Func::as_character($r, $x2);
    $x2 = Rstats::Func::factor($r, Rstats::Func::as_character($r, $x2));
  }
  
  return $x2;
}

sub set_array {
  my $r = shift;
  
  my $x1 = shift;
  my $x2 = Rstats::Func::to_object($r, shift);
  
  my $at = $x1->at;
  my $_indexs = ref $at eq 'ARRAY' ? $at : [$at];
  my ($poss, $x2_dim) = @{Rstats::Util::parse_index($r, $x1, 0, $_indexs)};
  
  my $type;
  my $x1_elements;
  if (Rstats::Func::is_factor($r, $x1)) {
    $x1_elements = Rstats::Func::decompose($r, $x1);
    $x2 = Rstats::Func::as_character($r, $x2) unless Rstats::Func::is_character($r, $x2);
    my $x2_elements = Rstats::Func::decompose($r, $x2);
    my $levels_h = Rstats::Func::_levels_h($r, $x1);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      my $element = $x2_elements->[(($i + 1) % @$poss) - 1];
      if (Rstats::Func::is_na($r, $element)) {
        $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
      }
      else {
        my $value = Rstats::Func::value($r, $element);
        if ($levels_h->{$value}) {
          $x1_elements->[$pos] = $levels_h->{$value};
        }
        else {
          Carp::carp "invalid factor level, NA generated";
          $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
        }
      }
    }
    $type = $x1->get_type;
  }
  else {
    # Upgrade mode if type is different
    if ($x1->get_type ne $x2->get_type) {
      my $x1_tmp;
      ($x1_tmp, $x2) = @{Rstats::Func::upgrade_type($r, [$x1, $x2])};
      Rstats::Func::copy_attrs_to($r, $x1_tmp, $x1);
      $x1->vector($x1_tmp->vector);
      
      $type = $x1_tmp->get_type;
    }
    else {
      $type = $x1->get_type;
    }

    $x1_elements = Rstats::Func::decompose($r, $x1);

    my $x2_elements = Rstats::Func::decompose($r, $x2);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      $x1_elements->[$pos] = $x2_elements->[(($i + 1) % @$poss) - 1];
    }
  }
  
  $DB::single = 1;
  my $x1_tmp = Rstats::Func::compose($r, $type, $x1_elements);
  $x1->vector($x1_tmp->vector);
  $x1->{type} = $x1_tmp->{type};
  $x1->{object_type} = $x1_tmp->{object_type};
  
  return $x1;
}

sub to_string_array {
  my $r = shift;
  
  my $x1 = shift;
  
  my $is_factor = Rstats::Func::is_factor($r, $x1);
  my $is_ordered = Rstats::Func::is_ordered($r, $x1);
  my $levels;
  if ($is_factor) {
    $levels = Rstats::Func::levels($r, $x1)->values;
  }
  
  $x1 = Rstats::Func::as_character($r, $x1) if Rstats::Func::is_factor($r, $x1);
  
  my $is_character = Rstats::Func::is_character($r, $x1);

  my $values = $x1->values;
  my $type = $x1->get_type;
  
  my $dim_values = $x1->dim_as_array->values;
  
  my $dim_length = @$dim_values;
  my $dim_num = $dim_length - 1;
  my $poss = [];
  
  my $str;
  if (@$values) {
    if ($dim_length == 1) {
      my $names = Rstats::Func::names($r, $x1)->values;
      if (@$names) {
        $str .= join(' ', @$names) . "\n";
      }
      my @parts = map { Rstats::Func::_value_to_string($r, $x1, $_, $type, $is_factor) } @$values;
      $str .= '[1] ' . join(' ', @parts) . "\n";
    }
    elsif ($dim_length == 2) {
      $str .= '     ';
      
      my $colnames = Rstats::Func::colnames($r, $x1)->values;
      if (@$colnames) {
        $str .= join(' ', @$colnames) . "\n";
      }
      else {
        for my $d2 (1 .. $dim_values->[1]) {
          $str .= $d2 == $dim_values->[1] ? "[,$d2]\n" : "[,$d2] ";
        }
      }
      
      my $rownames = Rstats::Func::rownames($r, $x1)->values;
      my $use_rownames = @$rownames ? 1 : 0;
      for my $d1 (1 .. $dim_values->[0]) {
        if ($use_rownames) {
          my $rowname = $rownames->[$d1 - 1];
          $str .= "$rowname ";
        }
        else {
          $str .= "[$d1,] ";
        }
        
        my @parts;
        for my $d2 (1 .. $dim_values->[1]) {
          my $part = $x1->value($d1, $d2);
          push @parts, Rstats::Func::_value_to_string($r, $x1, $part, $type, $is_factor);
        }
        
        $str .= join(' ', @parts) . "\n";
      }
    }
    else {
      my $code;
      $code = sub {
        my (@dim_values) = @_;
        my $dim_value = pop @dim_values;
        
        for (my $i = 1; $i <= $dim_value; $i++) {
          $str .= (',' x $dim_num) . "$i" . "\n";
          unshift @$poss, $i;
          if (@dim_values > 2) {
            $dim_num--;
            $code->(@dim_values);
            $dim_num++;
          }
          else {
            $str .= '     ';
            
            my $l_dimnames = Rstats::Func::dimnames($r, $x1);
            my $dimnames;
            if (Rstats::Func::is_null($r, $l_dimnames)) {
              $dimnames = [];
            }
            else {
              my $x_dimnames = $l_dimnames->getin($i);
              $dimnames = defined $l_dimnames ? $l_dimnames->values : [];
            }
            
            if (@$dimnames) {
              $str .= join(' ', @$dimnames) . "\n";
            }
            else {
              for my $d2 (1 .. $dim_values[1]) {
                $str .= $d2 == $dim_values[1] ? "[,$d2]\n" : "[,$d2] ";
              }
            }

            for my $d1 (1 .. $dim_values[0]) {
              $str .= "[$d1,] ";
              
              my @parts;
              for my $d2 (1 .. $dim_values[1]) {
                my $part = $x1->value($d1, $d2, @$poss);
                push @parts, Rstats::Func::_value_to_string($r, $x1, $part, $type, $is_factor);
              }
              
              $str .= join(' ', @parts) . "\n";
            }
          }
          shift @$poss;
        }
      };
      $code->(@$dim_values);
    }

    if ($is_factor) {
      if ($is_ordered) {
        $str .= 'Levels: ' . join(' < ', @$levels) . "\n";
      }
      else {
        $str .= 'Levels: ' . join(' ', , @$levels) . "\n";
      }
    }
  }
  else {
    $str = 'NULL';
  }
  
  return $str;
}

=cut
