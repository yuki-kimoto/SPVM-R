# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Operation::Int extends R::Operation {
  
  use R::NDArray::Int;
  use Fn;
  
  # Class Methods
  static method new : R::Operation::Int () {
    
    my $self = new R::Operation::Int;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::Int ($data : int[]) {
    
    unless ($data) {
      die "The data \$data must be defined.";
    }
    
    my $length = @$data;
    
    my $dim = (int[])undef;
    if ($length > 0) {
      $dim = [$length];
    }
    
    my $ndarray = R::NDArray::Int->new({dim => $dim, data => $data});
    
    return $ndarray;
  }
  
  method array : R::NDArray::Int ($data : int[], $dim : int[]) {
    
    my $ndarray = R::NDArray::Int->new({dim => $dim, data => $data});
    
    return $ndarray;
  }
  
  method add : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] + $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method sub : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] - $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method mul : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] * $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method div : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] / $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method div_unsinged : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] div_uint $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method mod : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] % $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method mod_unsinged : R::NDArray::Int ($ndarray1 : R::NDArray::Int, $ndarray2 : R::NDArray::Int) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new int[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i] mod_uint $data2->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method clone : R::NDArray::Int ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Int->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (int)$data->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method to_long : R::NDArray::Long ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Long->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (long)$data->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method to_float : R::NDArray::Float ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Float->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (float)$data->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method to_double : R::NDArray::Double ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Double->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (double)$data->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method to_float_complex : R::NDArray::FloatComplex ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::FloatComplex->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i]{re} = (float)$data->[$i];
      $data_ret->[$i]{im} = 0f;
    }
    
    return $ndarray_ret;
  }
  
  method to_double_complex : R::NDArray::DoubleComplex ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::DoubleComplex->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i]{re} = (double)$data->[$i];
      $data_ret->[$i]{im} = 0;
    }
    
    return $ndarray_ret;
  }
  
  method to_string : R::NDArray::String ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::String->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (string)$data->[$i];
    }
    
    return $ndarray_ret;
  }
  
  method abs : R::NDArray::Int ($ndarray : R::NDArray::Int) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Int->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Fn->abs($data->[$i]);
    }
    
    return $ndarray_ret;
  }
}

=pod TODO

namespace Rstats {
  namespace Func {
    
    SV* abs(SV*, SV*);
    SV* tanh(SV*, SV*);
    SV* acos(SV*, SV*);
    SV* acosh(SV*, SV*);
    SV* asin(SV*, SV*);
    SV* asinh(SV*, SV*);
    SV* atan(SV*, SV*);
    SV* atanh(SV*, SV*);
    SV* cos(SV*, SV*);
    SV* cosh(SV*, SV*);
    SV* cumsum(SV*, SV*);
    SV* cumprod(SV*, SV*);
    SV* exp(SV*, SV*);
    SV* expm1(SV*, SV*);
    SV* log(SV*, SV*);
    SV* logb(SV*, SV*);
    SV* log2(SV*, SV*);
    SV* log10(SV*, SV*);
    SV* prod(SV*, SV*);
    SV* sin(SV*, SV*);
    SV* sinh(SV*, SV*);
    SV* sqrt(SV*, SV*);
    SV* tan(SV*, SV*);
    SV* sin(SV*, SV*);
    SV* sum(SV*, SV*);
    SV* negate(SV*, SV*);
    SV* pow(SV*, SV*, SV*);
    SV* atan2(SV*, SV*, SV*);
    SV* less_than(SV*, SV*, SV*);
    SV* less_than_or_equal(SV*, SV*, SV*);
    SV* more_than(SV*, SV*, SV*);
    SV* more_than_or_equal(SV*, SV*, SV*);
    SV* equal(SV*, SV*, SV*);
    SV* not_equal(SV*, SV*, SV*);
    SV* And(SV*, SV*, SV*);
    SV* Or(SV*, SV*, SV*);
    SV* is_finite(SV*, SV*);
    SV* is_infinite(SV*, SV*);
    SV* is_nan(SV*, SV*);
    SV* Mod(SV*, SV*);
    SV* Arg(SV*, SV*);
    SV* Conj(SV*, SV*);
    SV* Re(SV*, SV*);
    SV* Im(SV*, SV*);
  }
}
#include "Rstats_Func_impl.h"

=cut
