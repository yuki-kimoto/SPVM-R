# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Operation::DoubleComplex extends R::Operation {
  
  use R::NDArray::Int;
  use R::NDArray::Long;
  use R::NDArray::Float;
  use R::NDArray::Double;
  use R::NDArray::FloatComplex;
  use R::NDArray::DoubleComplex;
  use R::NDArray::String;
  use R::Operation::Int;
  use R::Operation::Long;
  use R::Operation::Float;
  use R::Operation::Double;
  use R::Operation::FloatComplex;
  use R::Operation::DoubleComplex;
  use R::Operation::String;
  use Fn;
  use Complex_2f;
  use Complex_2d;
  use Math;
  
  # Class Methods
  static method new : R::Operation::DoubleComplex () {
    
    my $self = new R::Operation::DoubleComplex;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::DoubleComplex ($x_data : Complex_2d[], $x_dim : int[] = undef) {
    
    my $x_ndarray = R::NDArray::DoubleComplex->new({dim => $x_dim, data => $x_data});
    
    return $x_ndarray;
  }
  
  method add : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cadd($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sub : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csub($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method mul : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cmul($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method div : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cdiv($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method to_float_complex : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::FloatComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (float)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (float)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method clone : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::DoubleComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (double)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (double)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method to_string : R::NDArray::String ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::String->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = (string)$x_data->[$i]{re} . " + " . (string)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method abs : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cabs($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method neg : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cneg($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sin : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csin($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }

  precompile method cos : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccos($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tan : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctan($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sinh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csinh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method cosh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccosh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tanh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctanh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acos : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacos($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asin : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casin($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atan : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catan($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asinh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casinh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acosh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacosh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atanh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catanh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method exp : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cexp($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method log : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->clog($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sqrt : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csqrt($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method conj : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->conj($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method arg : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->carg($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method re : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re};
    }
    
    return $ret_ndarray;
  }
  

  precompile method im : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method pow : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cpow($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method eq : R::NDArray::Int ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method ne : R::NDArray::Int ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = !($x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im});
    }
    
    return $ret_ndarray;
  }
  
  precompile method sum : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2d;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->cadd($sum, $x_data->[$i]);
    }
    $ret_data->[0] = $sum;
    
    return $ret_ndarray;
  }
  
  precompile method cumsum : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2d;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->cadd($sum, $x_data->[$i]);
      $ret_data->[$i] = $sum;
    }
    
    return $ret_ndarray;
  }
  
  precompile method prod : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complex(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmul($prod, $x_data->[$i]);
    }
    $ret_data->[0] = $prod;
    
    return $ret_ndarray;
  }
  
  precompile method cumprod : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complex(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmul($prod, $x_data->[$i]);
      $ret_data->[$i] = $prod;
    }
    
    return $ret_ndarray;
  }
  
  method complex : R::NDArray::DoubleComplex ($pairs : double[]) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_length = @$pairs;
    
    unless ($pairs_length % 2 == 0) {
      die "The length of the pairs \$pairs must be even number.";
    }
    
    my $length = $pairs_length / 2;
    
    my $ret_ndarray = $self->c(undef, [$length]);
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $pairs_length; $i += 2) {
      $ret_data->[$i]{re} = $pairs->[$i];
      $ret_data->[$i]{im} = $pairs->[$i + 1];
    }
    
    return $ret_ndarray;
  }
  
  method i : R::NDArray::DoubleComplex () {
    
    my $i = $self->complex([0.0,1.0]);
    
    return $i;
  }
  
}

=pod TODO

sub ceiling {
  my $r = shift;
  my $_x1 = shift;
  
  my $x1 = to_object($r, $_x1);
  my @x2_elements
    = map { Rstats::Func::c_double($r, POSIX::ceil Rstats::Func::value($r, $_)) }
    @{Rstats::Func::decompose($r, $x1)};
  
  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub floor {
  my $r = shift;
  
  my $_x1 = shift;
  
  my $x1 = to_object($r, $_x1);
  
  my @x2_elements
    = map { Rstats::Func::c_double($r, POSIX::floor Rstats::Func::value($r, $_)) }
    @{Rstats::Func::decompose($r, $x1)};

  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub rep {
  my $r = shift;
  
  my ($x1, $x_times) = args_array($r, ['x1', 'times'], @_);
  
  my $times = defined $x_times ? $x_times->value : 1;
  
  my $elements = [];
  push @$elements, @{Rstats::Func::decompose($r, $x1)} for 1 .. $times;
  my $x2 = Rstats::Func::c_($r, @$elements);
  
  return $x2;
}

sub round {
  my $r = shift;
  
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my ($_x1, $digits) = @_;
  $digits = $opt->{digits} unless defined $digits;
  $digits = 0 unless defined $digits;
  
  my $x1 = to_object($r, $_x1);

  my $ro = 10 ** $digits;
  my @x2_elements = map { Rstats::Func::c_double($r, Math::Round::round_even(Rstats::Func::value($r, $_) * $ro) / $ro) } @{Rstats::Func::decompose($r, $x1)};
  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub seq {
  my $r = shift;
  
  # Option
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  
  # Along
  my $_along = $opt->{along};
  if (defined $_along) {
    my $along = to_object($r, $_along);
    my $length = Rstats::Func::get_length($r, $along);
    return seq($r, 1, $length);
  }
  else {
    my ($from, $to) = @_;
    
    # From
    $from = $opt->{from} unless defined $from;
    Carp::croak "seq function need from option" unless defined $from;
    
    # To
    $to = $opt->{to} unless defined $to;
    Carp::croak "seq function need to option" unless defined $to;

    # Length
    my $length = $opt->{length};
    
    # By
    my $by = $opt->{by};
    
    if (defined $length && defined $by) {
      Carp::croak "Can't use by option and length option as same time";
    }
    
    unless (defined $by) {
      if ($to >= $from) {
        $by = 1;
      }
      else {
        $by = -1;
      }
    }
    Carp::croak "by option should be except for 0" if $by == 0;
    
    $to = $from unless defined $to;
    
    if (defined $length && $from ne $to) {
      $by = ($to - $from) / ($length - 1);
    }
    
    my $elements = [];
    if ($to == $from) {
      $elements->[0] = $to;
    }
    elsif ($to > $from) {
      if ($by < 0) {
        Carp::croak "by option is invalid number(seq function)";
      }
      
      my $element = $from;
      while ($element <= $to) {
        push @$elements, $element;
        $element += $by;
      }
    }
    else {
      if ($by > 0) {
        Carp::croak "by option is invalid number(seq function)";
      }
      
      my $element = $from;
      while ($element >= $to) {
        push @$elements, $element;
        $element += $by;
      }
    }
    
    return Rstats::Func::c_($r, @$elements);
  }
}

sub set_array {
  my $r = shift;
  
  my $x1 = shift;
  my $x2 = Rstats::Func::to_object($r, shift);
  
  my $at = $x1->at;
  my $_indexs = ref $at eq 'ARRAY' ? $at : [$at];
  my ($poss, $x2_dim) = @{Rstats::Util::parse_index($r, $x1, 0, $_indexs)};
  
  my $type;
  my $x1_elements;
  if (Rstats::Func::is_factor($r, $x1)) {
    $x1_elements = Rstats::Func::decompose($r, $x1);
    $x2 = Rstats::Func::as_character($r, $x2) unless Rstats::Func::is_character($r, $x2);
    my $x2_elements = Rstats::Func::decompose($r, $x2);
    my $levels_h = Rstats::Func::_levels_h($r, $x1);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      my $element = $x2_elements->[(($i + 1) % @$poss) - 1];
      if (Rstats::Func::is_na($r, $element)) {
        $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
      }
      else {
        my $value = Rstats::Func::value($r, $element);
        if ($levels_h->{$value}) {
          $x1_elements->[$pos] = $levels_h->{$value};
        }
        else {
          Carp::carp "invalid factor level, NA generated";
          $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
        }
      }
    }
    $type = $x1->get_type;
  }
  else {
    # Upgrade mode if type is different
    if ($x1->get_type ne $x2->get_type) {
      my $x1_tmp;
      ($x1_tmp, $x2) = @{Rstats::Func::upgrade_type($r, [$x1, $x2])};
      Rstats::Func::copy_attrs_to($r, $x1_tmp, $x1);
      $x1->vector($x1_tmp->vector);
      
      $type = $x1_tmp->get_type;
    }
    else {
      $type = $x1->get_type;
    }

    $x1_elements = Rstats::Func::decompose($r, $x1);

    my $x2_elements = Rstats::Func::decompose($r, $x2);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      $x1_elements->[$pos] = $x2_elements->[(($i + 1) % @$poss) - 1];
    }
  }
  
  $DB::single = 1;
  my $x1_tmp = Rstats::Func::compose($r, $type, $x1_elements);
  $x1->vector($x1_tmp->vector);
  $x1->{type} = $x1_tmp->{type};
  $x1->{object_type} = $x1_tmp->{object_type};
  
  return $x1;
}

sub max {
  my $r = shift;

  my @args = grep { !Rstats::Func::is_null($r, $_) } @_;
  
  my $x1 = Rstats::Func::c_($r, @args);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to max; returning -Inf';
    return -(Rstats::Func::Inf($r));
  }
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $max = shift @$x1_elements;
  for my $element (@$x1_elements) {
    
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $max = $element;
    }
    if (!Rstats::Func::is_nan($r, $max) && Rstats::Func::value($r, $element > $max)) {
      $max = $element;
    }
  }
  
  return Rstats::Func::c_($r, $max);
}

sub mean {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  my $x2 = divide($r, sum($r, $x1), Rstats::Func::get_length($r, $x1));
  
  return $x2;
}

sub min {
  my $r = shift;
  
  my @args = grep { !Rstats::Func::is_null($r, $_) } @_;
  
  my $x1 = Rstats::Func::c_($r, @args);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to min; returning Inf';
    return Rstats::Func::Inf($r);
  }
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $min = shift @$x1_elements;
  for my $element (@$x1_elements) {
    
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $min = $element;
    }
    if (!Rstats::Func::is_nan($r, $min) && Rstats::Func::value($r, $element < $min)) {
      $min = $element;
    }
  }
  
  return Rstats::Func::c_($r, $min);
}

=cut
