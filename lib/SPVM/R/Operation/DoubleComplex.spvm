# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Operation::DoubleComplex extends R::Operation {
  
  use R::NDArray::Int;
  use R::NDArray::Long;
  use R::NDArray::Float;
  use R::NDArray::Double;
  use R::NDArray::FloatComplex;
  use R::NDArray::DoubleComplex;
  use R::NDArray::String;
  use R::Operation::Int;
  use R::Operation::Long;
  use R::Operation::Float;
  use R::Operation::Double;
  use R::Operation::FloatComplex;
  use R::Operation::DoubleComplex;
  use R::Operation::String;
  use Fn;
  use Complex_2f;
  use Complex_2d;
  use Math;
  
  # Class Methods
  static method new : R::Operation::DoubleComplex () {
    
    my $self = new R::Operation::DoubleComplex;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::DoubleComplex ($x_data : Complex_2d[], $x_dim : int[] = undef) {
    
    my $x_ndarray = R::NDArray::DoubleComplex->new({dim => $x_dim, data => $x_data});
    
    return $x_ndarray;
  }
  
  method add : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cadd($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sub : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csub($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method mul : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cmul($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method div : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_data = new Complex_2d[$length];
    my $ret_ndarray = $self->c($ret_data, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cdiv($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method to_float_complex : R::NDArray::FloatComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::FloatComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (float)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (float)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method clone : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::DoubleComplex->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i]{re} = (double)$x_data->[$i]{re};
      $ret_data->[$i]{im} = (double)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method to_string : R::NDArray::String ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::String->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = (string)$x_data->[$i]{re} . " + " . (string)$x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method abs : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cabs($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method neg : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cneg($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sin : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csin($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }

  precompile method cos : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccos($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tan : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctan($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sinh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csinh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method cosh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ccosh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method tanh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->ctanh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acos : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacos($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asin : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casin($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atan : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catan($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method asinh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->casinh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method acosh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cacosh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method atanh : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->catanh($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method exp : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cexp($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method log : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->clog($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method sqrt : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->csqrt($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method conj : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->conj($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method arg : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->carg($x_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method re : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re};
    }
    
    return $ret_ndarray;
  }
  

  precompile method im : R::NDArray::Double ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Double->new->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method pow : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = Math->cpow($x_data->[$i], $y_data->[$i]);
    }
    
    return $ret_ndarray;
  }
  
  precompile method eq : R::NDArray::Int ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = $x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im};
    }
    
    return $ret_ndarray;
  }
  
  precompile method ne : R::NDArray::Int ($x_ndarray : R::NDArray::DoubleComplex, $y_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    unless ($y_ndarray) {
      die "The n-dimension array \$y_ndarray must be defined.";
    }
    
    my $equals_dim = $self->equals_dim($x_ndarray, $y_ndarray);
    
    unless ($equals_dim) {
      die "The dim field of \$x_ndarray must be the same as the dim field of \$y_ndarray.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = R::Operation::Int->new->c(undef, $x_dim);
    my $ret_data = $ret_ndarray->data;
    
    my $x_data = $x_ndarray->data;
    my $y_data = $y_ndarray->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $ret_data->[$i] = !($x_data->[$i]{re} == $y_data->[$i]{re} && $x_data->[$i]{im} == $y_data->[$i]{im});
    }
    
    return $ret_ndarray;
  }
  
  precompile method sum : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2d;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->cadd($sum, $x_data->[$i]);
    }
    $ret_data->[0] = $sum;
    
    return $ret_ndarray;
  }
  
  precompile method cumsum : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $sum : Complex_2d;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->cadd($sum, $x_data->[$i]);
      $ret_data->[$i] = $sum;
    }
    
    return $ret_ndarray;
  }
  
  precompile method prod : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, [1]);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complex(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmul($prod, $x_data->[$i]);
    }
    $ret_data->[0] = $prod;
    
    return $ret_ndarray;
  }
  
  precompile method cumprod : R::NDArray::DoubleComplex ($x_ndarray : R::NDArray::DoubleComplex) {
    
    unless ($x_ndarray) {
      die "The n-dimension array \$x_ndarray must be defined.";
    }
    
    my $length = $x_ndarray->length;
    
    my $x_dim = $x_ndarray->dim;
    
    my $ret_ndarray = $self->c(undef, $x_dim);
    
    my $x_data = $x_ndarray->data;
    my $ret_data = $ret_ndarray->data;
    
    my $prod = Math->complex(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmul($prod, $x_data->[$i]);
      $ret_data->[$i] = $prod;
    }
    
    return $ret_ndarray;
  }
  
  method complex : R::NDArray::DoubleComplex ($pairs : double[]) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_length = @$pairs;
    
    unless ($pairs_length % 2 == 0) {
      die "The length of the pairs \$pairs must be even number.";
    }
    
    my $length = $pairs_length / 2;
    
    my $ret_ndarray = $self->c(undef, [$length]);
    my $ret_data = $ret_ndarray->data;
    
    for (my $i = 0; $i < $pairs_length; $i += 2) {
      $ret_data->[$i]{re} = $pairs->[$i];
      $ret_data->[$i]{im} = $pairs->[$i + 1];
    }
    
    return $ret_ndarray;
  }
  
  method i : R::NDArray::DoubleComplex () {
    
    my $i = $self->complex([0.0,1.0]);
    
    return $i;
  }
  
}

=pod TODO

sub match {
  my $r = shift;
  
  my ($x1, $x2) = (to_object($r, shift), to_object($r, shift));
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $x2_elements = Rstats::Func::decompose($r, $x2);
  my @matches;
  for my $x1_element (@$x1_elements) {
    my $i = 1;
    my $match;
    for my $x2_element (@$x2_elements) {
      if ($x1_element == $x2_element) {
        $match = 1;
        last;
      }
      $i++;
    }
    if ($match) {
      push @matches, $i;
    }
    else {
      push @matches, undef;
    }
  }
  
  return Rstats::Func::c_double($r, @matches);
}

sub diff {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  my $x2_elements = [];
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  for (my $i = 0; $i < Rstats::Func::get_length($r, $x1) - 1; $i++) {
    my $x1_element1 = $x1_elements->[$i];
    my $x1_element2 = $x1_elements->[$i + 1];
    my $x2_element = $x1_element2 - $x1_element1;
    push @$x2_elements, $x2_element;
  }
  my $x2 = Rstats::Func::c_($r, @$x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  
  return $x2;
}

sub setequal {
  my $r = shift;
  
  my ($x1, $x2) = (to_object($r, shift), to_object($r, shift));
  
  Carp::croak "mode is diffrence" if $x1->get_type ne $x2->get_type;
  
  my $x3 = Rstats::Func::sort($r, $x1);
  my $x4 = Rstats::Func::sort($r, $x2);
  
  return Rstats::Func::FALSE($r) if Rstats::Func::get_length($r, $x3) ne Rstats::Func::get_length($r, $x4);
  
  my $not_equal;
  my $x3_elements = Rstats::Func::decompose($r, $x3);
  my $x4_elements = Rstats::Func::decompose($r, $x4);
  for (my $i = 0; $i < Rstats::Func::get_length($r, $x3); $i++) {
    unless ($x3_elements->[$i] == $x4_elements->[$i]) {
      $not_equal = 1;
      last;
    }
  }
  
  return $not_equal ? Rstats::Func::FALSE($r) : TRUE($r);
}

sub setdiff {
  my $r = shift;
  
  my ($x1, $x2) = (to_object($r, shift), to_object($r, shift));
  
  Carp::croak "mode is diffrence" if $x1->get_type ne $x2->get_type;
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $x2_elements = Rstats::Func::decompose($r, $x2);
  my $x3_elements = [];
  for my $x1_element (@$x1_elements) {
    my $match;
    for my $x2_element (@$x2_elements) {
      if ($x1_element == $x2_element) {
        $match = 1;
        last;
      }
    }
    push @$x3_elements, $x1_element unless $match;
  }

  return Rstats::Func::c_($r, @$x3_elements);
}

sub intersect {
  my $r = shift;
  
  my ($x1, $x2) = (to_object($r, shift), to_object($r, shift));
  
  Carp::croak "mode is diffrence" if $x1->get_type ne $x2->get_type;
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $x2_elements = Rstats::Func::decompose($r, $x2);
  my $x3_elements = [];
  for my $x1_element (@$x1_elements) {
    for my $x2_element (@$x2_elements) {
      if ($x1_element == $x2_element) {
        push @$x3_elements, $x1_element;
      }
    }
  }
  
  return Rstats::Func::c_($r, @$x3_elements);
}

sub union {
  my $r = shift;
  
  my ($x1, $x2) = (to_object($r, shift), to_object($r, shift));

  Carp::croak "mode is diffrence" if $x1->get_type ne $x2->get_type;
  
  my $x3 = Rstats::Func::c_($r, $x1, $x2);
  my $x4 = unique($r, $x3);
  
  return $x4;
}

sub t {
  my $r = shift;
  
  my $x1 = shift;
  
  my $x1_row = Rstats::Func::dim($r, $x1)->values->[0];
  my $x1_col = Rstats::Func::dim($r, $x1)->values->[1];
  
  my $x2 = matrix($r, 0, $x1_col, $x1_row);
  
  for my $row (1 .. $x1_row) {
    for my $col (1 .. $x1_col) {
      my $value = $x1->value($row, $col);
      $x2->at($col, $row);
      Rstats::Func::set($r, $x2, $value);
    }
  }
  
  return $x2;
}

sub upper_tri {
  my $r = shift;
  
  my ($x1_m, $x1_diag) = args_array($r, ['m', 'diag'], @_);
  
  my $diag = defined $x1_diag ? $x1_diag->value : 0;
  
  my $x2_values = [];
  if (Rstats::Func::is_matrix($r, $x1_m)) {
    my $x1_dim_values = Rstats::Func::dim($r, $x1_m)->values;
    my $rows_count = $x1_dim_values->[0];
    my $cols_count = $x1_dim_values->[1];
    
    for (my $col = 0; $col < $cols_count; $col++) {
      for (my $row = 0; $row < $rows_count; $row++) {
        my $x2_value;
        if ($diag) {
          $x2_value = $col >= $row ? 1 : 0;
        }
        else {
          $x2_value = $col > $row ? 1 : 0;
        }
        push @$x2_values, $x2_value;
      }
    }
    
    my $x2 = matrix($r, Rstats::Func::c_logical($r, @$x2_values), $rows_count, $cols_count);
    
    return $x2;
  }
  else {
    Carp::croak 'Error in upper_tri() : Not implemented';
  }
}

sub lower_tri {
  my $r = shift;
  
  my ($x1_m, $x1_diag) = args_array($r, ['m', 'diag'], @_);
  
  my $diag = defined $x1_diag ? $x1_diag->value : 0;
  
  my $x2_values = [];
  if (Rstats::Func::is_matrix($r, $x1_m)) {
    my $x1_dim_values = Rstats::Func::dim($r, $x1_m)->values;
    my $rows_count = $x1_dim_values->[0];
    my $cols_count = $x1_dim_values->[1];
    
    for (my $col = 0; $col < $cols_count; $col++) {
      for (my $row = 0; $row < $rows_count; $row++) {
        my $x2_value;
        if ($diag) {
          $x2_value = $col <= $row ? 1 : 0;
        }
        else {
          $x2_value = $col < $row ? 1 : 0;
        }
        push @$x2_values, $x2_value;
      }
    }
    
    my $x2 = matrix($r, Rstats::Func::c_logical($r, @$x2_values), $rows_count, $cols_count);
    
    return $x2;
  }
  else {
    Carp::croak 'Error in lower_tri() : Not implemented';
  }
}

sub diag {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  my $size;
  my $x2_values;
  if (Rstats::Func::get_length($r, $x1) == 1) {
    $size = $x1->value;
    $x2_values = [];
    push @$x2_values, 1 for (1 .. $size);
  }
  else {
    $size = Rstats::Func::get_length($r, $x1);
    $x2_values = $x1->values;
  }
  
  my $x2 = matrix($r, 0, $size, $size);
  for (my $i = 0; $i < $size; $i++) {
    $x2->at($i + 1, $i + 1);
    $x2->set($x2_values->[$i]);
  }

  return $x2;
}

sub set_diag {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  my $x2 = to_object($r, shift);
  
  my $x2_elements;
  my $x1_dim_values = Rstats::Func::dim($r, $x1)->values;
  my $size = $x1_dim_values->[0] < $x1_dim_values->[1] ? $x1_dim_values->[0] : $x1_dim_values->[1];
  
  $x2 = array($r, $x2, $size);
  my $x2_values = $x2->values;
  
  for (my $i = 0; $i < $size; $i++) {
    $x1->at($i + 1, $i + 1);
    $x1->set($x2_values->[$i]);
  }
  
  return $x1;
}

sub kronecker {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  my $x2 = to_object($r, shift);
  
  ($x1, $x2) = @{Rstats::Func::upgrade_type($r, [$x1, $x2])} if $x1->get_type ne $x2->get_type;
  
  my $x1_dim = Rstats::Func::dim($r, $x1);
  my $x2_dim = Rstats::Func::dim($r, $x2);
  my $dim_max_length
    = Rstats::Func::get_length($r, $x1_dim) > Rstats::Func::get_length($r, $x2_dim) ? Rstats::Func::get_length($r, $x1_dim) : Rstats::Func::get_length($r, $x2_dim);
  
  my $x3_dim_values = [];
  my $x1_dim_values = $x1_dim->values;
  my $x2_dim_values = $x2_dim->values;
  for (my $i = 0; $i < $dim_max_length; $i++) {
    my $x1_dim_value = $x1_dim_values->[$i] || 1;
    my $x2_dim_value = $x2_dim_values->[$i] || 1;
    my $x3_dim_value = $x1_dim_value * $x2_dim_value;
    push @$x3_dim_values, $x3_dim_value;
  }
  
  my $x3_dim_product = 1;
  $x3_dim_product *= $_ for @{$x3_dim_values};
  
  my $x3_values = [];
  for (my $i = 0; $i < $x3_dim_product; $i++) {
    my $x3_index = Rstats::Util::pos_to_index($i, $x3_dim_values);
    my $x1_index = [];
    my $x2_index = [];
    for (my $k = 0; $k < @$x3_index; $k++) {
      my $x3_i = $x3_index->[$k];
      
      my $x1_dim_value = $x1_dim_values->[$k] || 1;
      my $x2_dim_value = $x2_dim_values->[$k] || 1;

      my $x1_ind = int(($x3_i - 1)/$x2_dim_value) + 1;
      push @$x1_index, $x1_ind;
      my $x2_ind = $x3_i - $x2_dim_value * ($x1_ind - 1);
      push @$x2_index, $x2_ind;
    }
    my $x1_value = $x1->value(@$x1_index);
    my $x2_value = $x2->value(@$x2_index);
    my $x3_value = multiply($r, $x1_value, $x2_value);
    push @$x3_values, $x3_value;
  }
  
  my $x3 = array($r, c_($r, @$x3_values), Rstats::Func::c_($r, @$x3_dim_values));
  
  return $x3;
}

sub outer {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  my $x2 = to_object($r, shift);
  
  ($x1, $x2) = @{Rstats::Func::upgrade_type($r, [$x1, $x2])} if $x1->get_type ne $x2->get_type;
  
  my $x1_dim = Rstats::Func::dim($r, $x1);
  my $x2_dim = Rstats::Func::dim($r, $x2);
  my $x3_dim = [@{$x1_dim->values}, @{$x2_dim->values}];
  
  my $indexs = [];
  for my $x3_d (@$x3_dim) {
    push @$indexs, [1 .. $x3_d];
  }
  my $poses = Rstats::Util::cross_product($indexs);
  
  my $x1_dim_length = Rstats::Func::get_length($r, $x1_dim);
  my $x3_values = [];
  for my $pos (@$poses) {
    my $pos_tmp = [@$pos];
    my $x1_pos = [splice @$pos_tmp, 0, $x1_dim_length];
    my $x2_pos = $pos_tmp;
    my $x1_value = $x1->value(@$x1_pos);
    my $x2_value = $x2->value(@$x2_pos);
    my $x3_value = $x1_value * $x2_value;
    push @$x3_values, $x3_value;
  }
  
  my $x3 = array($r, c_($r, @$x3_values), Rstats::Func::c_($r, @$x3_dim));
  
  return $x3;
}

    SV* cross_product(SV* sv_values) {
      
      Rstats::Integer values_length = Rstats::pl_av_len(sv_values);
      SV* sv_idxs = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        Rstats::pl_av_push(sv_idxs, Rstats::pl_new_sv_iv(0)); 
      }
      
      SV* sv_idx_idx = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        Rstats::pl_av_push(sv_idx_idx, Rstats::pl_new_sv_iv(i));
      }
      
      SV* sv_x1 = Rstats::pl_new_avrv();
      for (Rstats::Integer i = 0; i < values_length; i++) {
        SV* sv_value = Rstats::pl_av_fetch(sv_values, i);
        Rstats::pl_av_push(sv_x1, Rstats::pl_av_fetch(sv_value, 0));
      }

      SV* sv_result = Rstats::pl_new_avrv();
      Rstats::pl_av_push(sv_result, Rstats::pl_av_copy(sv_x1));
      Rstats::Logical end_loop = 0;
      while (1) {
        for (Rstats::Integer i = 0; i < values_length; i++) {
          
          if (SvIV(Rstats::pl_av_fetch(sv_idxs, i)) < Rstats::pl_av_len(Rstats::pl_av_fetch(sv_values, i)) - 1) {
            
            SV* sv_idxs_tmp = Rstats::pl_av_fetch(sv_idxs, i);
            sv_inc(sv_idxs_tmp);
            Rstats::pl_av_store(sv_x1, i, Rstats::pl_av_fetch(Rstats::pl_av_fetch(sv_values, i), SvIV(sv_idxs_tmp)));
            
            Rstats::pl_av_push(sv_result, Rstats::pl_av_copy(sv_x1));
            
            break;
          }
          
          if (i == SvIV(Rstats::pl_av_fetch(sv_idx_idx, values_length - 1))) {
            end_loop = 1;
            break;
          }
          
          Rstats::pl_av_store(sv_idxs, i, Rstats::pl_new_sv_iv(0));
          Rstats::pl_av_store(sv_x1, i, Rstats::pl_av_fetch(Rstats::pl_av_fetch(sv_values, i), 0));
        }
        if (end_loop) {
          break;
        }
      }

      return sv_result;
    }

sub cbind {
  my $r = shift;
  
  my @xs = @_;

  return Rstats::Func::NULL($r) unless @xs;
  
  if (Rstats::Func::is_data_frame($r, $xs[0])) {
    # Check row count
    my $first_row_length;
    my $different;
    for my $x (@xs) {
      if ($first_row_length) {
        $different = 1 if $x->{row_length} != $first_row_length;
      }
      else {
        $first_row_length = $x->{row_length};
      }
    }
    Carp::croak "cbind need same row count data frame"
      if $different;
    
    # Create new data frame
    my @data_frame_args;
    for my $x (@xs) {
      my $names = Rstats::Func::names($r, $x)->values;
      for my $name (@$names) {
        push @data_frame_args, $name, $x->getin($name);
      }
    }
    my $data_frame = Rstats::Func::data_frame($r, @data_frame_args);
    
    return $data_frame;
  }
  else {
    my $row_count_needed;
    my $col_count_total;
    my $x2_elements = [];
    for my $_x (@xs) {
      
      my $x1 = to_object($r, $_x);
      my $x1_dim_elements = Rstats::Func::decompose($r, Rstats::Func::dim($r, $x1));
      
      my $row_count;
      if (Rstats::Func::is_matrix($r, $x1)) {
        $row_count = $x1_dim_elements->[0];
        $col_count_total += $x1_dim_elements->[1];
      }
      elsif (Rstats::Func::is_vector($r, $x1)) {
        $row_count = $x1->dim_as_array->values->[0];
        $col_count_total += 1;
      }
      else {
        Carp::croak "cbind or rbind can only receive matrix and vector";
      }
      
      $row_count_needed = $row_count unless defined $row_count_needed;
      Carp::croak "Row count is different" if $row_count_needed ne $row_count;
      
      push @$x2_elements, @{Rstats::Func::decompose($r, $x1)};
    }
    my $matrix = matrix($r, c_($r, @$x2_elements), $row_count_needed, $col_count_total);
    
    return $matrix;
  }
}

sub ceiling {
  my $r = shift;
  my $_x1 = shift;
  
  my $x1 = to_object($r, $_x1);
  my @x2_elements
    = map { Rstats::Func::c_double($r, POSIX::ceil Rstats::Func::value($r, $_)) }
    @{Rstats::Func::decompose($r, $x1)};
  
  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub colMeans {
  my $r = shift;
  my $x1 = shift;
  
  my $dim_values = Rstats::Func::dim($r, $x1)->values;
  if (@$dim_values == 2) {
    my $x1_values = [];
    for my $row (1 .. $dim_values->[0]) {
      my $x1_value = 0;
      $x1_value += $x1->value($row, $_) for (1 .. $dim_values->[1]);
      push @$x1_values, $x1_value / $dim_values->[1];
    }
    return Rstats::Func::c_($r, @$x1_values);
  }
  else {
    Carp::croak "Can't culculate colSums";
  }
}

sub colSums {
  my $r = shift;
  my $x1 = shift;
  
  my $dim_values = Rstats::Func::dim($r, $x1)->values;
  if (@$dim_values == 2) {
    my $x1_values = [];
    for my $row (1 .. $dim_values->[0]) {
      my $x1_value = 0;
      $x1_value += $x1->value($row, $_) for (1 .. $dim_values->[1]);
      push @$x1_values, $x1_value;
    }
    return Rstats::Func::c_($r, @$x1_values);
  }
  else {
    Carp::croak "Can't culculate colSums";
  }
}

sub cummax {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to max; returning -Inf';
    return -(Rstats::Func::Inf($r));
  }
  
  my @x2_elements;
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $max = shift @$x1_elements;
  push @x2_elements, $max;
  for my $element (@$x1_elements) {
    
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $max = $element;
    }
    if ($element > $max && !Rstats::Func::is_nan($r, $max)) {
      $max = $element;
    }
    push @x2_elements, $max;
  }
  
  return Rstats::Func::c_($r, @x2_elements);
}

sub cummin {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to max; returning -Inf';
    return -(Rstats::Func::Inf($r));
  }
  
  my @x2_elements;
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $min = shift @$x1_elements;
  push @x2_elements, $min;
  for my $element (@$x1_elements) {
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $min = $element;
    }
    if ($element < $min && !Rstats::Func::is_nan($r, $min)) {
      $min = $element;
    }
    push @x2_elements, $min;
  }
  
  return Rstats::Func::c_($r, @x2_elements);
}

sub floor {
  my $r = shift;
  
  my $_x1 = shift;
  
  my $x1 = to_object($r, $_x1);
  
  my @x2_elements
    = map { Rstats::Func::c_double($r, POSIX::floor Rstats::Func::value($r, $_)) }
    @{Rstats::Func::decompose($r, $x1)};

  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub head {
  my $r = shift;
  
  my ($x1, $x_n) = args_array($r, ['x1', 'n'], @_);
  
  my $n = defined $x_n ? $x_n->value : 6;
  
  if (Rstats::Func::is_data_frame($r, $x1)) {
    my $max = $x1->{row_length} < $n ? $x1->{row_length} : $n;
    
    my $x_range = Rstats::Func::C_($r, "1:$max");
    my $x2 = $x1->get($x_range, Rstats::Func::NULL($r));
    
    return $x2;
  }
  else {
    my $x1_elements = Rstats::Func::decompose($r, $x1);
    my $max = Rstats::Func::get_length($r, $x1) < $n ? Rstats::Func::get_length($r, $x1) : $n;
    my @x2_elements;
    for (my $i = 0; $i < $max; $i++) {
      push @x2_elements, $x1_elements->[$i];
    }
    
    my $x2 = Rstats::Func::c_($r, @x2_elements);
    Rstats::Func::copy_attrs_to($r, $x1, $x2);
  
    return $x2;
  }
}

sub max {
  my $r = shift;

  my @args = grep { !Rstats::Func::is_null($r, $_) } @_;
  
  my $x1 = Rstats::Func::c_($r, @args);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to max; returning -Inf';
    return -(Rstats::Func::Inf($r));
  }
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $max = shift @$x1_elements;
  for my $element (@$x1_elements) {
    
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $max = $element;
    }
    if (!Rstats::Func::is_nan($r, $max) && Rstats::Func::value($r, $element > $max)) {
      $max = $element;
    }
  }
  
  return Rstats::Func::c_($r, $max);
}

sub mean {
  my $r = shift;
  
  my $x1 = to_object($r, shift);
  
  my $x2 = divide($r, sum($r, $x1), Rstats::Func::get_length($r, $x1));
  
  return $x2;
}

sub min {
  my $r = shift;
  
  my @args = grep { !Rstats::Func::is_null($r, $_) } @_;
  
  my $x1 = Rstats::Func::c_($r, @args);
  
  unless (Rstats::Func::get_length($r, $x1)) {
    Carp::carp 'no non-missing arguments to min; returning Inf';
    return Rstats::Func::Inf($r);
  }
  
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  my $min = shift @$x1_elements;
  for my $element (@$x1_elements) {
    
    if (Rstats::Func::is_na($r, $element)) {
      return Rstats::Func::NA($r);
    }
    elsif (Rstats::Func::is_nan($r, $element)) {
      $min = $element;
    }
    if (!Rstats::Func::is_nan($r, $min) && Rstats::Func::value($r, $element < $min)) {
      $min = $element;
    }
  }
  
  return Rstats::Func::c_($r, $min);
}

sub order {
  my $r = shift;
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my @xs = map { to_object($r, $_) } @_;
  
  my @xs_values;
  for my $x (@xs) {
    push @xs_values, $x->values;
  }

  my $decreasing = $opt->{decreasing} || Rstats::Func::FALSE($r);
  
  my @pos_vals;
  for my $i (0 .. @{$xs_values[0]} - 1) {
    my $pos_val = {pos => $i + 1};
    $pos_val->{val} = [];
    push @{$pos_val->{val}}, $xs_values[$_][$i] for (0 .. @xs_values);
    push @pos_vals, $pos_val;
  }
  
  my @sorted_pos_values = !$decreasing
    ? sort {
        my $comp;
        for (my $i = 0; $i < @xs_values; $i++) {
          $comp = $a->{val}[$i] <=> $b->{val}[$i];
          last if $comp != 0;
        }
        $comp;
      } @pos_vals
    : sort {
        my $comp;
        for (my $i = 0; $i < @xs_values; $i++) {
          $comp = $b->{val}[$i] <=> $a->{val}[$i];
          last if $comp != 0;
        }
        $comp;
      } @pos_vals;
  my @orders = map { $_->{pos} } @sorted_pos_values;
  
  return Rstats::Func::c_($r, @orders);
}

# TODO
# na.last
sub rank {
  my $r = shift;
  
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my $x1 = to_object($r, shift);
  my $decreasing = $opt->{decreasing};
  
  my $x1_values = $x1->values;
  
  my @pos_vals;
  push @pos_vals, {pos => $_ + 1, value => $x1_values->[$_]} for (0 .. @$x1_values - 1);
  my @sorted_pos_values = sort { $a->{value} <=> $b->{value} } @pos_vals;
  
  # Rank
  for (my $i = 0; $i < @sorted_pos_values; $i++) {
    $sorted_pos_values[$i]{rank} = $i + 1;
  }
  
  # Average rank
  my $element_info = {};
  for my $sorted_pos_value (@sorted_pos_values) {
    my $value = $sorted_pos_value->{value};
    $element_info->{$value} ||= {};
    $element_info->{$value}{rank_total} += $sorted_pos_value->{rank};
    $element_info->{$value}{rank_count}++;
  }
  
  for my $sorted_pos_value (@sorted_pos_values) {
    my $value = $sorted_pos_value->{value};
    $sorted_pos_value->{rank_average}
      = $element_info->{$value}{rank_total} / $element_info->{$value}{rank_count};
  }
  
  my @sorted_pos_values2 = sort { $a->{pos} <=> $b->{pos} } @sorted_pos_values;
  my @rank = map { $_->{rank_average} } @sorted_pos_values2;
  
  return Rstats::Func::c_($r, @rank);
}

sub range {
  my $r = shift;
  
  my $x1 = shift;
  
  my $min = min($r, $x1);
  my $max = max($r, $x1);
  
  return Rstats::Func::c_($r, $min, $max);
}

sub rbind {
  my $r = shift;
  my (@xs) = @_;
  
  return Rstats::Func::NULL($r) unless @xs;
  
  if (Rstats::Func::is_data_frame($r, $xs[0])) {
    
    # Check names
    my $first_names;
    for my $x (@xs) {
      if ($first_names) {
        my $names = Rstats::Func::names($r, $x)->values;
        my $different;
        $different = 1 if @$first_names != @$names;
        for (my $i = 0; $i < @$first_names; $i++) {
          $different = 1 if $names->[$i] ne $first_names->[$i];
        }
        Carp::croak "rbind require same names having data frame"
          if $different;
      }
      else {
        $first_names = Rstats::Func::names($r, $x)->values;
      }
    }
    
    # Create new vectors
    my @new_vectors;
    for my $name (@$first_names) {
      my @vectors;
      for my $x (@xs) {
        my $v = $x->getin($name);
        if (Rstats::Func::is_factor($r, $v)) {
          push @vectors, Rstats::Func::as_character($r, $v);
        }
        else {
          push @vectors, $v;
        }
      }
      my $new_vector = Rstats::Func::c_($r, @vectors);
      push @new_vectors, $new_vector;
    }
    
    # Create new data frame
    my @data_frame_args;
    for (my $i = 0; $i < @$first_names; $i++) {
      push @data_frame_args, $first_names->[$i], $new_vectors[$i];
    }
    my $data_frame = Rstats::Func::data_frame($r, @data_frame_args);
    
    return $data_frame;
  }
  else {
    my $matrix = cbind($r, @xs);
    
    return Rstats::Func::t($r, $matrix);
  }
}

sub rep {
  my $r = shift;
  
  my ($x1, $x_times) = args_array($r, ['x1', 'times'], @_);
  
  my $times = defined $x_times ? $x_times->value : 1;
  
  my $elements = [];
  push @$elements, @{Rstats::Func::decompose($r, $x1)} for 1 .. $times;
  my $x2 = Rstats::Func::c_($r, @$elements);
  
  return $x2;
}

sub rev {
  my $r = shift;
  
  my $x1 = shift;
  
  # Reverse elements
  my @x2_elements = reverse @{Rstats::Func::decompose($r, $x1)};
  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  
  return $x2;
}

sub rnorm {
  my $r = shift;
  
  # Option
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  
  # Count
  my ($count, $mean, $sd) = @_;
  Carp::croak "rnorm count should be bigger than 0"
    if $count < 1;
  
  # Mean
  $mean = 0 unless defined $mean;
  
  # Standard deviation
  $sd = 1 unless defined $sd;
  
  # Random numbers(standard deviation)
  my @x1_elements;
  
  my $pi = $r->pi->value;
  for (1 .. $count) {
    my ($rand1, $rand2) = (rand, rand);
    while ($rand1 == 0) { $rand1 = rand(); }
    
    my $rnorm = ($sd * CORE::sqrt(-2 * CORE::log($rand1))
      * CORE::sin(2 * $pi * $rand2))
      + $mean;
    
    push @x1_elements, $rnorm;
  }
  
  return Rstats::Func::c_($r, @x1_elements);
}

sub round {
  my $r = shift;
  
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  my ($_x1, $digits) = @_;
  $digits = $opt->{digits} unless defined $digits;
  $digits = 0 unless defined $digits;
  
  my $x1 = to_object($r, $_x1);

  my $ro = 10 ** $digits;
  my @x2_elements = map { Rstats::Func::c_double($r, Math::Round::round_even(Rstats::Func::value($r, $_) * $ro) / $ro) } @{Rstats::Func::decompose($r, $x1)};
  my $x2 = Rstats::Func::c_($r, @x2_elements);
  Rstats::Func::copy_attrs_to($r, $x1, $x2);
  Rstats::Func::mode($r, $x2, 'double');
  
  return $x2;
}

sub rowMeans {
  my $r = shift;
  
  my $x1 = shift;
  
  my $dim_values = Rstats::Func::dim($r, $x1)->values;
  if (@$dim_values == 2) {
    my $x1_values = [];
    for my $col (1 .. $dim_values->[1]) {
      my $x1_value = 0;
      $x1_value += $x1->value($_, $col) for (1 .. $dim_values->[0]);
      push @$x1_values, $x1_value / $dim_values->[0];
    }
    return Rstats::Func::c_($r, @$x1_values);
  }
  else {
    Carp::croak "Can't culculate rowMeans";
  }
}

sub rowSums {
  my $r = shift;
  
  my $x1 = shift;
  
  my $dim_values = Rstats::Func::dim($r, $x1)->values;
  if (@$dim_values == 2) {
    my $x1_values = [];
    for my $col (1 .. $dim_values->[1]) {
      my $x1_value = 0;
      $x1_value += $x1->value($_, $col) for (1 .. $dim_values->[0]);
      push @$x1_values, $x1_value;
    }
    return Rstats::Func::c_($r, @$x1_values);
  }
  else {
    Carp::croak "Can't culculate rowSums";
  }
}

# TODO: prob option
sub sample {
  my $r = shift;
  
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  
  my ($_x1, $length) = @_;
  my $x1 = to_object($r, $_x1);
  
  # Replace
  my $replace = $opt->{replace};
  
  my $x1_length = Rstats::Func::get_length($r, $x1);
  $length = $x1_length unless defined $length;
  
  Carp::croak "second argument element must be bigger than first argument elements count when you specify 'replace' option"
    if $length > $x1_length && !$replace;
  
  my @x2_elements;
  my $x1_elements = Rstats::Func::decompose($r, $x1);
  for my $i (0 .. $length - 1) {
    my $rand_num = int(rand @$x1_elements);
    my $rand_element = splice @$x1_elements, $rand_num, 1;
    push @x2_elements, $rand_element;
    push @$x1_elements, $rand_element if $replace;
  }
  
  return Rstats::Func::c_($r, @x2_elements);
}

sub seq {
  my $r = shift;
  
  # Option
  my $opt = ref $_[-1] eq 'HASH' ? pop @_ : {};
  
  # Along
  my $_along = $opt->{along};
  if (defined $_along) {
    my $along = to_object($r, $_along);
    my $length = Rstats::Func::get_length($r, $along);
    return seq($r, 1, $length);
  }
  else {
    my ($from, $to) = @_;
    
    # From
    $from = $opt->{from} unless defined $from;
    Carp::croak "seq function need from option" unless defined $from;
    
    # To
    $to = $opt->{to} unless defined $to;
    Carp::croak "seq function need to option" unless defined $to;

    # Length
    my $length = $opt->{length};
    
    # By
    my $by = $opt->{by};
    
    if (defined $length && defined $by) {
      Carp::croak "Can't use by option and length option as same time";
    }
    
    unless (defined $by) {
      if ($to >= $from) {
        $by = 1;
      }
      else {
        $by = -1;
      }
    }
    Carp::croak "by option should be except for 0" if $by == 0;
    
    $to = $from unless defined $to;
    
    if (defined $length && $from ne $to) {
      $by = ($to - $from) / ($length - 1);
    }
    
    my $elements = [];
    if ($to == $from) {
      $elements->[0] = $to;
    }
    elsif ($to > $from) {
      if ($by < 0) {
        Carp::croak "by option is invalid number(seq function)";
      }
      
      my $element = $from;
      while ($element <= $to) {
        push @$elements, $element;
        $element += $by;
      }
    }
    else {
      if ($by > 0) {
        Carp::croak "by option is invalid number(seq function)";
      }
      
      my $element = $from;
      while ($element >= $to) {
        push @$elements, $element;
        $element += $by;
      }
    }
    
    return Rstats::Func::c_($r, @$elements);
  }
}

sub runif {
  my $r = shift;

  my ($x_count, $x_min, $x_max)
    =  Rstats::Func::args_array($r, ['count', 'min', 'max'], @_);
  
  my $count = $x_count->value;
  my $min = defined $x_min ? $x_min->value : 0;
  my $max = defined $x_max ? $x_max->value : 1;
  Carp::croak "runif third argument must be bigger than second argument"
    if $min > $max;
  
  my $diff = $max - $min;
  my @x1_elements;
  if (defined $r->{seed}) {
    srand $r->{seed};
  }
  
  for (1 .. $count) {
    my $rand = rand($diff) + $min;
    push @x1_elements, $rand;
  }
  
  $r->{seed} = undef;
  
  return Rstats::Func::c_($r, @x1_elements);
}

sub set_array {
  my $r = shift;
  
  my $x1 = shift;
  my $x2 = Rstats::Func::to_object($r, shift);
  
  my $at = $x1->at;
  my $_indexs = ref $at eq 'ARRAY' ? $at : [$at];
  my ($poss, $x2_dim) = @{Rstats::Util::parse_index($r, $x1, 0, $_indexs)};
  
  my $type;
  my $x1_elements;
  if (Rstats::Func::is_factor($r, $x1)) {
    $x1_elements = Rstats::Func::decompose($r, $x1);
    $x2 = Rstats::Func::as_character($r, $x2) unless Rstats::Func::is_character($r, $x2);
    my $x2_elements = Rstats::Func::decompose($r, $x2);
    my $levels_h = Rstats::Func::_levels_h($r, $x1);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      my $element = $x2_elements->[(($i + 1) % @$poss) - 1];
      if (Rstats::Func::is_na($r, $element)) {
        $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
      }
      else {
        my $value = Rstats::Func::value($r, $element);
        if ($levels_h->{$value}) {
          $x1_elements->[$pos] = $levels_h->{$value};
        }
        else {
          Carp::carp "invalid factor level, NA generated";
          $x1_elements->[$pos] = Rstats::Func::c_logical($r, undef);
        }
      }
    }
    $type = $x1->get_type;
  }
  else {
    # Upgrade mode if type is different
    if ($x1->get_type ne $x2->get_type) {
      my $x1_tmp;
      ($x1_tmp, $x2) = @{Rstats::Func::upgrade_type($r, [$x1, $x2])};
      Rstats::Func::copy_attrs_to($r, $x1_tmp, $x1);
      $x1->vector($x1_tmp->vector);
      
      $type = $x1_tmp->get_type;
    }
    else {
      $type = $x1->get_type;
    }

    $x1_elements = Rstats::Func::decompose($r, $x1);

    my $x2_elements = Rstats::Func::decompose($r, $x2);
    for (my $i = 0; $i < @$poss; $i++) {
      my $pos = $poss->[$i];
      $x1_elements->[$pos] = $x2_elements->[(($i + 1) % @$poss) - 1];
    }
  }
  
  $DB::single = 1;
  my $x1_tmp = Rstats::Func::compose($r, $type, $x1_elements);
  $x1->vector($x1_tmp->vector);
  $x1->{type} = $x1_tmp->{type};
  $x1->{object_type} = $x1_tmp->{object_type};
  
  return $x1;
}

sub sort {
  my $r = shift;
  
  my ($x1, $x_decreasing) = Rstats::Func::args_array($r, ['x1', 'decreasing', 'na.last'], @_);
  
  my $decreasing = defined $x_decreasing ? $x_decreasing->value : 0;
  
  my @x2_elements = grep { !Rstats::Func::is_na($r, $_) && !Rstats::Func::is_nan($r, $_) } @{Rstats::Func::decompose($r, $x1)};
  
  my $x3_elements = $decreasing
    ? [reverse sort { ($a > $b) ? 1 : ($a == $b) ? 0 : -1 } @x2_elements]
    : [sort { ($a > $b) ? 1 : ($a == $b) ? 0 : -1 } @x2_elements];

  return Rstats::Func::c_($r, @$x3_elements);
}

=cut
