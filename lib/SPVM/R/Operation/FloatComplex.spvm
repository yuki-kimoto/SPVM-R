# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R::Operation::FloatComplex extends R::Operation {
  
  use R::NDArray::FloatComplex;
  use Complex_2f;
  use Fn;
  use Math;
  
  # Class Methods
  static method new : R::Operation::FloatComplex () {
    
    my $self = new R::Operation::FloatComplex;
    
    return $self;
  }
  
  # Instance Methods
  method c : R::NDArray::FloatComplex ($data : Complex_2f[]) {
    
    unless ($data) {
      die "The data \$data must be defined.";
    }
    
    my $length = @$data;
    
    my $dim = (int[])undef;
    if ($length > 0) {
      $dim = [$length];
    }
    
    my $ndarray = R::NDArray::FloatComplex->new({dim => $dim, data => $data});
    
    return $ndarray;
  }
  
  method array : R::NDArray::FloatComplex ($data : Complex_2f[], $dim : int[]) {
    
    my $ndarray = R::NDArray::FloatComplex->new({dim => $dim, data => $data});
    
    return $ndarray;
  }
  
  method add : R::NDArray::FloatComplex ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new Complex_2f[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->caddf($data1->[$i], $data2->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method sub : R::NDArray::FloatComplex ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new Complex_2f[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->csubf($data1->[$i], $data2->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method mul : R::NDArray::FloatComplex ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new Complex_2f[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cmulf($data1->[$i], $data2->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method div : R::NDArray::FloatComplex ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $data_ret = new Complex_2f[$length];
    my $ndarray_ret = $self->array($data_ret, $dim);
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cdivf($data1->[$i], $data2->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method clone : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::FloatComplex->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i]{re} = (float)$data->[$i]{re};
      $data_ret->[$i]{im} = (float)$data->[$i]{im};
    }
    
    return $ndarray_ret;
  }
  
  method to_double_complex : R::NDArray::DoubleComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::DoubleComplex->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i]{re} = (double)$data->[$i]{re};
      $data_ret->[$i]{im} = (double)$data->[$i]{im};
    }
    
    return $ndarray_ret;
  }
  
  method to_string : R::NDArray::String ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::String->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = (string)$data->[$i]{re} . " + " . (string)$data->[$i]{im};
    }
    
    return $ndarray_ret;
  }
  
  method abs : R::NDArray::Float ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Float->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cabsf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method neg : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cnegf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method sin : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->csinf($data->[$i]);
    }
    
    return $ndarray_ret;
  }

  method cos : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->ccosf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method tan : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->ctanf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method sinh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->csinhf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method cosh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->ccoshf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method tanh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->ctanhf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method acos : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cacosf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method asin : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->casinf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method atan : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->catanf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method asinh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->casinhf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method acosh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cacoshf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method atanh : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->catanhf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method exp : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cexpf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method log : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->clogf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method sqrt : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->csqrtf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method conj : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->conjf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method arg : R::NDArray::Float ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Float->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cargf($data->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method re : R::NDArray::Float ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Float->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data->[$i]{re};
    }
    
    return $ndarray_ret;
  }
  
  method im : R::NDArray::Float ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = R::Operation::Float->new->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data->[$i]{im};
    }
    
    return $ndarray_ret;
  }
  
  method pow : R::NDArray::FloatComplex ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    my $data_ret = $ndarray_ret->data;
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = Math->cpowf($data1->[$i], $data2->[$i]);
    }
    
    return $ndarray_ret;
  }
  
  method eq : R::NDArray::Int ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $ndarray_ret = R::Operation::Int->new->array(undef, $dim);
    my $data_ret = $ndarray_ret->data;
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = $data1->[$i]{re} == $data2->[$i]{re} && $data1->[$i]{im} == $data2->[$i]{im};
    }
    
    return $ndarray_ret;
  }
  
  method ne : R::NDArray::Int ($ndarray1 : R::NDArray::FloatComplex, $ndarray2 : R::NDArray::FloatComplex) {
    
    my $equals_dim = $self->equals_dim($ndarray1, $ndarray2);
    
    unless ($equals_dim) {
      die "The dim field of \$ndarray1 must be the same as the dim field of \$ndarray2.";
    }
    
    my $length = $ndarray1->length;
    
    my $dim = $ndarray1->dim;
    
    my $ndarray_ret = R::Operation::Int->new->array(undef, $dim);
    my $data_ret = $ndarray_ret->data;
    
    my $data1 = $ndarray1->data;
    my $data2 = $ndarray2->data;
    
    for (my $i = 0; $i < $length; $i++) {
      $data_ret->[$i] = !($data1->[$i]{re} == $data2->[$i]{re} && $data1->[$i]{im} == $data2->[$i]{im});
    }
    
    return $ndarray_ret;
  }
  
  method sum : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, [1]);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    my $sum : Complex_2f;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->caddf($sum, $data->[$i]);
    }
    $data_ret->[0] = $sum;
    
    return $ndarray_ret;
  }
  
  method cumsum : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    my $sum : Complex_2f;
    for (my $i = 0; $i < $length; $i++) {
      $sum = Math->caddf($sum, $data->[$i]);
      $data_ret->[$i] = $sum;
    }
    
    return $ndarray_ret;
  }
  
  method prod : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, [1]);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    my $prod = Math->complexf(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmulf($prod, $data->[$i]);
    }
    $data_ret->[0] = $prod;
    
    return $ndarray_ret;
  }
  
  method cumprod : R::NDArray::FloatComplex ($ndarray : R::NDArray::FloatComplex) {
    
    unless ($ndarray) {
      die "The n-dimension array \$ndarray must be defined.";
    }
    
    my $length = $ndarray->length;
    
    my $dim = $ndarray->dim;
    
    my $ndarray_ret = $self->array(undef, $dim);
    
    my $data = $ndarray->data;
    my $data_ret = $ndarray_ret->data;
    
    my $prod = Math->complexf(1, 0);
    for (my $i = 0; $i < $length; $i++) {
      $prod = Math->cmulf($prod, $data->[$i]);
      $data_ret->[$i] = $prod;
    }
    
    return $ndarray_ret;
  }
  
}
