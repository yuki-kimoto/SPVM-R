# Copyright (c) 2024 Yuki Kimoto
# MIT License

class R {
  version "0.004";
  
  use StringBuffer;
  use Time::Piece;
  use Complex_2d;
  use Complex_2f;
  
  use R::NDArray::Byte;
  use R::NDArray::Short;
  use R::NDArray::Int;
  use R::NDArray::Long;
  use R::NDArray::Float;
  use R::NDArray::Double;
  use R::NDArray::FloatComplex;
  use R::NDArray::DoubleComplex;
  use R::NDArray::Object;
  use R::NDArray::String;
  use R::NDArray::StringBuffer;
  use R::NDArray::Time::Piece;
  
  use R::OP::Byte;
  use R::OP::Short;
  use R::OP::Int;
  use R::OP::Long;
  use R::OP::Float;
  use R::OP::Double;
  use R::OP::FloatComplex;
  use R::OP::DoubleComplex;
  use R::OP::Object;
  use R::OP::String;
  use R::OP::StringBuffer;
  use R::OP::Time::Piece;
  
  static method byte : R::NDArray::Byte ($data : object of Byte|byte[]|R::NDArray::Byte, $dim : int[] = undef) {
    
    return R::OP::Byte->c($data, $dim);
  }
  
  static method short : R::NDArray::Short ($data : object of Short|short[]|R::NDArray::Short, $dim : int[] = undef) {
    
    if ($data) {
      if ($data is_type Short) {
        $data = [(short)$data->(Short)];
      }
      elsif ($data is_type short[]) {
        # Do nothing
      }
      elsif ($data is_type R::NDArray::Short) {
        unless ($dim) {
          $dim = $data->(R::NDArray::Short)->dim;
        }
        $data = $data->(R::NDArray::Short)->data;
      }
      else {
        die "The type of the data \data must be Short or short[].";
      }
    }
    
    return R::OP::Short->c((short[])$data, $dim);
  }
  
  static method int : R::NDArray::Int ($data : object of Short|int[]|R::NDArray::Int, $dim : int[] = undef) {
    
    if ($data) {
      if ($data is_type Int) {
        $data = [(int)$data->(Int)];
      }
      elsif ($data is_type int[]) {
        # Do nothing
      }
      elsif ($data is_type R::NDArray::Int) {
        unless ($dim) {
          $dim = $data->(R::NDArray::Int)->dim;
        }
        $data = $data->(R::NDArray::Int)->data;
      }
      else {
        die "The type of the data \data must be Int or int[].";
      }
    }
    
    return R::OP::Int->c((int[])$data, $dim);
  }
  
  static method long : R::NDArray::Long ($data : object of Long|long[]|R::NDArray::Long, $dim : int[] = undef) {
    
    if ($data) {
      if ($data is_type Long) {
        $data = [(long)$data->(Long)];
      }
      elsif ($data is_type long[]) {
        # Do nothing
      }
      elsif ($data is_type R::NDArray::Long) {
        unless ($dim) {
          $dim = $data->(R::NDArray::Long)->dim;
        }
        $data = $data->(R::NDArray::Long)->data;
      }
      else {
        die "The type of the data \data must be Long or long[].";
      }
    }
    
    return R::OP::Long->c((long[])$data, $dim);
  }
  
  static method float : R::NDArray::Float ($data : object of Float|float[]|R::NDArray::Float, $dim : int[] = undef) {
    
    if ($data) {
      if ($data is_type Float) {
        $data = [(float)$data->(Float)];
      }
      elsif ($data is_type float[]) {
        # Do nothing
      }
      elsif ($data is_type R::NDArray::Float) {
        unless ($dim) {
          $dim = $data->(R::NDArray::Float)->dim;
        }
        $data = $data->(R::NDArray::Float)->data;
      }
      else {
        die "The type of the data \data must be Float or float[].";
      }
    }
    
    return R::OP::Float->c((float[])$data, $dim);
  }
  
  static method double : R::NDArray::Double ($data : object of Double|double[]|R::NDArray::Double, $dim : int[] = undef) {
    
    if ($data) {
      if ($data is_type Double) {
        $data = [(double)$data->(Double)];
      }
      elsif ($data is_type double[]) {
        # Do nothing
      }
      elsif ($data is_type R::NDArray::Double) {
        unless ($dim) {
          $dim = $data->(R::NDArray::Double)->dim;
        }
        $data = $data->(R::NDArray::Double)->data;
      }
      else {
        die "The type of the data \data must be Double or double[].";
      }
    }
    
    return R::OP::Double->c((double[])$data, $dim);
  }
  
  static method float_complex : R::NDArray::FloatComplex ($data : Complex_2f[], $dim : int[] = undef) {
    return R::OP::FloatComplex->c($data, $dim);
  }
  
  static method double_complex : R::NDArray::DoubleComplex ($data : Complex_2d[], $dim : int[] = undef) {
    return R::OP::DoubleComplex->c($data, $dim);
  }
  
  static method complexf : R::NDArray::FloatComplex ($pairs : float[], $dim : int[] = undef) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_length = @$pairs;
    
    unless ($pairs_length % 2 == 0) {
      die "The pairs \$pairs must be devided by even number.";
    }
    
    my $length = $pairs_length / 2;
    
    my $data = new Complex_2f[$length];
    
    Fn->memcpy($data, 0, $pairs, 0, 4 * 2 * $length);
    
    return R::OP::FloatComplex->c($data, $dim);
  }
  
  static method complex : R::NDArray::DoubleComplex ($pairs : double[], $dim : int[] = undef) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_length = @$pairs;
    
    unless ($pairs_length % 2 == 0) {
      die "The pairs \$pairs must be devided by even number.";
    }
    
    my $length = $pairs_length / 2;
    
    my $data = new Complex_2d[$length];
    
    Fn->memcpy($data, 0, $pairs, 0, 8 * 2 * $length);
    
    return R::OP::DoubleComplex->c($data, $dim);
  }
  
  static method i : R::NDArray::DoubleComplex () {
    
    my $ret_ndarray = &complex([(double)0, 1]);
    
    return $ret_ndarray;
  }
  
  static method object : R::NDArray::Object ($data : object[], $dim : int[] = undef) {
    return R::OP::Object->c($data, $dim);
  }
  
  static method string : R::NDArray::String ($data : string[], $dim : int[] = undef) {
    return R::OP::String->c($data, $dim);
  }
  
  static method string_buffer : R::NDArray::StringBuffer ($data : StringBuffer[], $dim : int[] = undef) {
    return R::OP::StringBuffer->c($data, $dim);
  }
  
  static method time_piece : R::NDArray::Time::Piece ($data : Time::Piece[], $dim : int[] = undef) {
    return R::OP::Time::Piece->c($data, $dim);
  }
  
  static method seq : R::NDArray::Int ($begin : int, $end : int, $by : int = 1) {
    return R::OP::Int->seq($begin, $end, $by);
  }
  
  static method undef : R::NDArray::Int () {
    return (R::NDArray::Int)undef;
  }
}
